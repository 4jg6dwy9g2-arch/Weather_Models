{% extends "base.html" %}

{% block title %}Fairfax Verification - Weather Forecast{% endblock %}

{% block extra_css %}
<style>
    .time-selector {
        display: flex;
        gap: 8px;
        flex-wrap: wrap;
    }
    .time-selector .btn {
        min-width: 50px;
    }

    .freezing-line {
        border-top: 2px dashed rgba(100, 149, 237, 0.5);
    }

    .table-preview {
        max-height: 240px;
        overflow-y: auto;
    }
</style>
{% endblock %}

{% block content %}
<div class="mb-4">
    <div class="row align-items-center">
        <div class="col-md-6">
            <h1 class="mb-1"><i class="bi bi-cloud-sun"></i> Fairfax Verification</h1>
            <p class="mb-0 opacity-75">GFS vs ECMWF AIFS vs ECMWF IFS model forecasts</p>
        </div>
        <div class="col-md-6"></div>
    </div>
</div>

<div id="loadingState" class="loading-spinner d-none">
    <div class="text-center">
        <div class="spinner-border text-primary" role="status"></div>
        <p class="mt-2 text-muted">Loading forecast data...</p>
    </div>
</div>

<div id="errorState" class="alert alert-warning d-none">
    <i class="bi bi-exclamation-triangle"></i>
    <span id="errorMessage">No data available.</span>
    <a href="/sync" class="alert-link ms-2">Go to Sync tab to fetch data</a>
</div>

<div id="forecastContent">
    <!-- Model Legend -->
    <div class="model-legend">
        <div class="model-legend-item">
            <span class="model-dot model-dot-gfs"></span>
            <span>GFS (NOAA)</span>
        </div>
        <div class="model-legend-item">
            <span class="model-dot model-dot-aifs"></span>
            <span>AIFS (ECMWF ML)</span>
        </div>
        <div class="model-legend-item">
            <span class="model-dot model-dot-ifs"></span>
            <span>IFS (ECMWF NWP)</span>
        </div>
        <div class="model-legend-item">
            <span class="model-dot" style="background-color: #7c3aed;"></span>
            <span>Pangu (when available)</span>
        </div>
        <div class="model-legend-item" id="observedLegend" style="display: none;">
            <span class="model-dot" style="background-color: #28a745;"></span>
            <span>Observed (WeatherLink)</span>
        </div>
    </div>

    <!-- Verification Stats (only shown when available) -->
    <div id="verificationSection" class="row mb-4" style="display: none;">
        <div class="col-12">
            <div class="card">
                <div class="card-header d-flex justify-content-between align-items-center flex-wrap gap-2">
                    <div><i class="bi bi-check-circle"></i> Model Verification by Lead Time (vs Observed)</div>
                    <div class="d-flex align-items-center gap-3">
                        <div class="form-check form-switch mb-0">
                            <input class="form-check-input" type="checkbox" role="switch" id="fairfaxPeriodToggle">
                            <label class="form-check-label" for="fairfaxPeriodToggle">Last 30 days</label>
                        </div>
                        <button class="btn btn-sm btn-outline-secondary" type="button"
                                id="verificationTableToggle">
                            Expand table
                        </button>
                    </div>
                </div>
                <div class="card-body p-0">
                    <div class="table-responsive table-preview" id="verificationTableContainer">
                        <table class="table table-hover mb-0">
                            <thead>
                                <tr>
                                    <th>Lead Time</th>
                                    <th>Days</th>
                                    <th colspan="2" class="text-center bg-danger bg-opacity-10">GFS Temperature</th>
                                    <th colspan="2" class="text-center bg-warning bg-opacity-10">AIFS Temperature</th>
                                    <th colspan="2" class="text-center bg-success bg-opacity-10">IFS Temperature</th>
                                    <th colspan="2" class="text-center bg-dark bg-opacity-10">NWS Temperature</th>
                                    <th>Winner</th>
                                    <th colspan="2" class="text-center bg-danger bg-opacity-10">GFS Pressure</th>
                                    <th colspan="2" class="text-center bg-warning bg-opacity-10">AIFS Pressure</th>
                                    <th colspan="2" class="text-center bg-success bg-opacity-10">IFS Pressure</th>
                                    <th>Samples</th>
                                </tr>
                                <tr>
                                    <th></th>
                                    <th></th>
                                    <th class="text-center">MAE</th>
                                    <th class="text-center">Bias</th>
                                    <th class="text-center">MAE</th>
                                    <th class="text-center">Bias</th>
                                    <th class="text-center">MAE</th>
                                    <th class="text-center">Bias</th>
                                    <th class="text-center">MAE</th>
                                    <th class="text-center">Bias</th>
                                    <th></th>
                                    <th class="text-center">MAE</th>
                                    <th class="text-center">Bias</th>
                                    <th class="text-center">MAE</th>
                                    <th class="text-center">Bias</th>
                                    <th class="text-center">MAE</th>
                                    <th class="text-center">Bias</th>
                                    <th></th>
                                </tr>
                            </thead>
                            <tbody id="verificationTableBody">
                                <tr>
                                    <td colspan="18" class="text-center text-muted">Loading...</td>
                                </tr>
                            </tbody>
                        </table>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Verification Time Series Chart -->
    <div id="fairfaxTimeSeriesSection" class="row mb-4" style="display: none;">
        <div class="col-12">
            <div class="card">
                <div class="card-header d-flex justify-content-between align-items-center flex-wrap gap-2">
                    <div>
                        <i class="bi bi-graph-up"></i> Verification Trends Over Time
                    </div>
                    <div class="d-flex gap-2 flex-wrap">
                        <select class="form-select form-select-sm" id="fairfaxTsVariable" style="width: auto;">
                            <option value="temp" selected>Temperature</option>
                            <option value="mslp">Pressure</option>
                            <option value="precip">Precipitation</option>
                        </select>
                        <select class="form-select form-select-sm" id="fairfaxTsMetric" style="width: auto;">
                            <option value="mae" selected>MAE</option>
                            <option value="bias">Bias</option>
                        </select>
                        <select class="form-select form-select-sm" id="fairfaxTsLeadTime" style="width: auto;">
                            <option value="6">6h</option>
                            <option value="12">12h</option>
                            <option value="24" selected>24h</option>
                            <option value="48">48h</option>
                            <option value="72">72h</option>
                            <option value="120">5d</option>
                            <option value="168">7d</option>
                            <option value="240">10d</option>
                            <option value="288">12d</option>
                            <option value="360">15d</option>
                        </select>
                        <select class="form-select form-select-sm" id="fairfaxTsTimeFrame" style="width: auto;">
                            <option value="7">1 week</option>
                            <option value="30" selected>1 month</option>
                            <option value="90">3 months</option>
                            <option value="180">6 months</option>
                            <option value="365">1 year</option>
                        </select>
                    </div>
                </div>
                <div class="card-body">
                    <div id="fairfaxWinnerTally" class="alert alert-light mb-3 d-none">
                        <strong><i class="bi bi-trophy"></i> Daily Winners (Lowest MAE):</strong>
                        <span class="ms-3"><span class="badge bg-primary">GFS</span> <span id="fairfaxGfsWins">0</span> days</span>
                        <span class="ms-2"><span class="badge bg-info text-dark">AIFS</span> <span id="fairfaxAifsWins">0</span> days</span>
                        <span class="ms-2"><span class="badge bg-success">IFS</span> <span id="fairfaxIfsWins">0</span> days</span>
                        <span class="ms-2"><span class="badge bg-dark">NWS</span> <span id="fairfaxNwsWins">0</span> days</span>
                        <span class="ms-2"><span class="badge bg-secondary">Tie</span> <span id="fairfaxTieWins">0</span> days</span>
                    </div>
                    <div class="chart-container" style="position: relative; height: 400px;">
                        <canvas id="fairfaxTimeSeriesChart"></canvas>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Temperature Chart -->
    <div class="row mb-4">
        <div class="col-12">
            <div class="card">
                <div class="card-header d-flex justify-content-between align-items-center flex-wrap gap-2">
                    <div>
                        <span><i class="bi bi-thermometer-half"></i> Temperature Forecast & Historical Bias</span>
                        <small class="text-muted d-block" id="gfsInitTime"></small>
                    </div>
                    <div class="d-flex gap-2 flex-wrap">
                        <select class="form-select form-select-sm" id="tempBiasLeadTime" style="width: auto;">
                            <option value="6">6h lead</option>
                            <option value="12">12h lead</option>
                            <option value="24" selected>24h lead</option>
                            <option value="48">48h lead</option>
                            <option value="72">72h lead</option>
                            <option value="120">5d lead</option>
                            <option value="168">7d lead</option>
                        </select>
                        <select class="form-select form-select-sm" id="tempBiasTimeFrame" style="width: auto;">
                            <option value="7">1 week history</option>
                            <option value="14">2 weeks history</option>
                            <option value="30" selected>1 month history</option>
                            <option value="60">2 months history</option>
                            <option value="90">3 months history</option>
                        </select>
                    </div>
                </div>
                <div class="card-body">
                    <div class="chart-container chart-container-large">
                        <canvas id="tempChart"></canvas>
                    </div>
                    <div class="chart-container mt-3" style="height: 180px;">
                        <canvas id="tempBiasChart"></canvas>
                    </div>
                    <div class="alert alert-info mt-3 mb-0">
                        <strong>Interpretation:</strong> Black dots with line show observed temperatures (historical). Colored bars extend from observations showing model bias (upward = too warm, downward = too cold). Colored lines show model forecasts extending into the future.
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Precipitation Chart -->
    <div class="row mb-4">
        <div class="col-12">
            <div class="card">
                <div class="card-header d-flex justify-content-between align-items-center flex-wrap gap-2">
                    <div>
                        <span><i class="bi bi-cloud-rain"></i> Daily Precipitation (CoCoRaHS)</span>
                    </div>
                    <div class="d-flex gap-2 align-items-center flex-wrap">
                        <select class="form-select form-select-sm" id="precipBiasLeadTime" style="width: auto;">
                            <option value="6">6h lead</option>
                            <option value="12">12h lead</option>
                            <option value="24" selected>24h lead</option>
                            <option value="48">48h lead</option>
                            <option value="72">72h lead</option>
                            <option value="120">5d lead</option>
                            <option value="168">7d lead</option>
                        </select>
                        <select class="form-select form-select-sm" id="precipDaysBack" style="width: auto;">
                            <option value="7" selected>1 week history</option>
                            <option value="14">2 weeks history</option>
                            <option value="30">1 month history</option>
                            <option value="60">2 months history</option>
                            <option value="90">3 months history</option>
                        </select>
                        <small class="text-muted" id="aifsInitTime"></small>
                    </div>
                </div>
                <div class="card-body">
                    <div id="precipWinnerTally" class="alert alert-light mb-3 d-none">
                        <strong><i class="bi bi-trophy"></i> Daily Winners (Lowest |Bias|):</strong>
                        <span class="ms-3"><span class="badge bg-primary">GFS</span> <span id="precipGfsWins">0</span> days</span>
                        <span class="ms-2"><span class="badge bg-info text-dark">AIFS</span> <span id="precipAifsWins">0</span> days</span>
                        <span class="ms-2"><span class="badge bg-success">IFS</span> <span id="precipIfsWins">0</span> days</span>
                        <span class="ms-2"><span class="badge bg-secondary">Tie</span> <span id="precipTieWins">0</span> days</span>
                    </div>
                    <div class="chart-container chart-container-large">
                        <canvas id="precipChart"></canvas>
                    </div>
                    <div class="chart-container mt-3" style="height: 180px;">
                        <canvas id="precipBiasChart"></canvas>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- MSLP Chart -->
    <div class="row mb-4">
        <div class="col-12">
            <div class="card">
                <div class="card-header d-flex justify-content-between align-items-center flex-wrap gap-2">
                    <div>
                        <span><i class="bi bi-speedometer"></i> Mean Sea Level Pressure Forecast & Historical Bias</span>
                    </div>
                    <div class="d-flex gap-2 flex-wrap">
                        <select class="form-select form-select-sm" id="mslpBiasLeadTime" style="width: auto;">
                            <option value="6">6h lead</option>
                            <option value="12">12h lead</option>
                            <option value="24" selected>24h lead</option>
                            <option value="48">48h lead</option>
                            <option value="72">72h lead</option>
                            <option value="120">5d lead</option>
                            <option value="168">7d lead</option>
                        </select>
                        <select class="form-select form-select-sm" id="mslpBiasTimeFrame" style="width: auto;">
                            <option value="7">1 week history</option>
                            <option value="14">2 weeks history</option>
                            <option value="30" selected>1 month history</option>
                            <option value="60">2 months history</option>
                            <option value="90">3 months history</option>
                        </select>
                    </div>
                </div>
                <div class="card-body">
                    <div class="chart-container chart-container-large">
                        <canvas id="mslpChart"></canvas>
                    </div>
                    <div class="chart-container mt-3" style="height: 180px;">
                        <canvas id="mslpBiasChart"></canvas>
                    </div>
                    <div class="alert alert-info mt-3 mb-0">
                        <strong>Interpretation:</strong> Black dots with line show observed pressure (historical). Colored bars extend from observations showing model bias (upward = too high, downward = too low). Colored lines show model forecasts extending into the future.
                    </div>
                </div>
            </div>
        </div>
    </div>



<div id="verificationContent" class="d-none">
    <!-- Summary Stats -->
    <div class="row mb-4">
        <div class="col-lg-2 col-md-4 col-6 mb-3">
            <div class="card stat-card">
                <div class="stat-value" id="totalRuns">--</div>
                <div class="stat-label">Model Runs</div>
            </div>
        </div>
    </div>

    <!-- Model Legend -->
    <div class="model-legend">
        <div class="model-legend-item">
            <span class="model-dot model-dot-gfs"></span>
            <span>GFS (NOAA)</span>
        </div>
        <div class="model-legend-item">
            <span class="model-dot model-dot-aifs"></span>
            <span>AIFS (ECMWF ML)</span>
        </div>
        <div class="model-legend-item">
            <span class="model-dot model-dot-ifs"></span>
            <span>IFS (ECMWF NWP)</span>
        </div>
    </div>


    <!-- Historical Runs List -->
    <div class="row">
        <div class="col-12">
            <div class="card">
                <div class="card-header">
                    <i class="bi bi-clock-history"></i> Historical Model Runs
                </div>
                <div class="card-body p-0">
                    <div class="table-responsive">
                        <table class="table table-hover mb-0">
                            <thead>
                                <tr>
                                    <th>Init Time</th>
                                    <th>Fetched At</th>
                                    <th>Has Observations</th>
                                    <th>Temp MAE</th>
                                    <th>MSLP MAE</th>
                                </tr>
                            </thead>
                            <tbody id="runsTable">
                                <!-- Populated by JavaScript -->
                            </tbody>
                        </table>
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
    <!-- Model Info -->
    <div class="row mt-4">
        <div class="col-md-4 mb-3">
            <div class="card h-100">
                <div class="card-header">
                    <i class="bi bi-info-circle"></i> GFS (Global Forecast System)
                </div>
                <div class="card-body">
                    <ul class="mb-0">
                        <li>Operated by NOAA/NCEP</li>
                        <li>Resolution: 0.25° (~28 km)</li>
                        <li>Updates: Every 6 hours</li>
                        <li>Range: 16 days (384 hours)</li>
                        <li>Physics-based NWP model</li>
                    </ul>
                </div>
            </div>
        </div>
        <div class="col-md-4 mb-3">
            <div class="card h-100">
                <div class="card-header">
                    <i class="bi bi-info-circle"></i> ECMWF AIFS (AI Forecast)
                </div>
                <div class="card-body">
                    <ul class="mb-0">
                        <li>Operated by ECMWF</li>
                        <li>Resolution: 0.25° (~28 km)</li>
                        <li>Updates: Every 6 hours</li>
                        <li>Range: 15 days (360 hours)</li>
                        <li>Machine learning model</li>
                    </ul>
                </div>
            </div>
        </div>
        <div class="col-md-4 mb-3">
            <div class="card h-100">
                <div class="card-header">
                    <i class="bi bi-info-circle"></i> ECMWF IFS (Integrated Forecast)
                </div>
                <div class="card-body">
                    <ul class="mb-0">
                        <li>Operated by ECMWF</li>
                        <li>Resolution: 0.25° (~28 km)</li>
                        <li>Updates: Every 6 hours</li>
                        <li>Range: 10 days (240 hours)</li>
                        <li>Physics-based NWP model</li>
                    </ul>
                </div>
            </div>
        </div>
    </div>
</div>
{% endblock %}

{% block extra_js %}
<script>
let currentData = null;
let panguOverlay = null;
let nwsOverlay = null;

// Format time for display
function formatTime(dateStr) {
    const date = new Date(dateStr);
    return date.toLocaleString('en-US', {
        month: 'short',
        day: 'numeric',
        hour: 'numeric',
        hour12: true
    });
}

function formatShortTime(dateStr) {
    const date = new Date(dateStr);
    return date.toLocaleString('en-US', {
        month: 'short',
        day: 'numeric'
    });
}

// Get temperature badge class
function getTempClass(temp) {
    if (temp < 32) return 'temp-cold';
    if (temp < 50) return 'temp-cool';
    if (temp < 75) return 'temp-warm';
    return 'temp-hot';
}

// Load forecast data from saved files
async function loadForecast() {
    const location = 'Fairfax, VA';
    const tempLeadTime = document.getElementById('tempBiasLeadTime').value;
    const tempTimeFrame = document.getElementById('tempBiasTimeFrame').value;
    const mslpLeadTime = document.getElementById('mslpBiasLeadTime').value;
    const mslpTimeFrame = document.getElementById('mslpBiasTimeFrame').value;

    document.getElementById('loadingState').classList.remove('d-none');
    document.getElementById('forecastContent').classList.add('d-none');
    document.getElementById('errorState').classList.add('d-none');

    try {
        // Load from saved data, verification, and historical bias for both temp and MSLP
        const verificationPeriod = document.getElementById('fairfaxPeriodToggle')?.checked ? 'monthly' : 'all';
        const [forecastResponse, verificationResponse, tempBiasHistoryResponse, mslpBiasHistoryResponse, precipDailyResponse, panguResponse, nwsResponse] = await Promise.all([
            fetch(`/api/latest-forecast?location=${encodeURIComponent(location)}`),
            fetch(`/api/verification-by-lead-time?location=${encodeURIComponent(location)}&period=${verificationPeriod}`),
            fetch(`/api/temp-bias-history?location=${encodeURIComponent(location)}&lead_time=${tempLeadTime}&days_back=${tempTimeFrame}`),
            fetch(`/api/mslp-bias-history?location=${encodeURIComponent(location)}&lead_time=${mslpLeadTime}&days_back=${mslpTimeFrame}`),
            fetch(`/api/precip-daily-history?location=${encodeURIComponent(location)}&days_back=${document.getElementById('precipDaysBack')?.value || tempTimeFrame}&future_days=15&lead_time=${document.getElementById('precipBiasLeadTime')?.value || 24}`),
            fetch(`/api/pangu-latest?location=${encodeURIComponent(location)}`),
            fetch(`/api/nws-forecast-cache`)
        ]);

        const data = await forecastResponse.json();
        const verificationData = await verificationResponse.json();
        const tempBiasHistoryData = await tempBiasHistoryResponse.json();
        const mslpBiasHistoryData = await mslpBiasHistoryResponse.json();
        const precipDailyData = await precipDailyResponse.json();
        const panguData = await panguResponse.json();
        const nwsData = await nwsResponse.json();

        if (!data.success) {
            throw new Error(data.error || 'No saved data available');
        }

        currentData = data;
        document.getElementById('loadingState').classList.add('d-none');
        document.getElementById('forecastContent').classList.remove('d-none');

        // Render combined forecast + historical bias charts
        const tempHistoryData = tempBiasHistoryData.success ? tempBiasHistoryData.history : null;
        const mslpHistoryData = mslpBiasHistoryData.success ? mslpBiasHistoryData.history : null;
        panguOverlay = panguData && panguData.success ? panguData : null;
        nwsOverlay = nwsData && nwsData.success ? nwsData : null;
        const precipHistoryData = precipDailyData && precipDailyData.success ? precipDailyData : null;
        renderForecastCharts(data, tempHistoryData, mslpHistoryData, precipHistoryData, panguOverlay, nwsOverlay);

        updateInitTimes(data);
        updateFetchedTime(data);
        updateObservedLegend(data);

        // Render verification table with accumulated data across all runs
        if (verificationData.success && verificationData.verification.lead_times.length > 0) {
            renderVerificationTable(verificationData.verification);
            document.getElementById('verificationSection').style.display = '';
        } else {
            const tbody = document.getElementById('verificationTableBody');
            tbody.innerHTML = '<tr><td colspan="10" class="text-center text-muted">No verification data available yet. Sync forecasts and wait for observations.</td></tr>';
            document.getElementById('verificationSection').style.display = '';
        }

    } catch (error) {
        console.error('Error loading forecast:', error);
        document.getElementById('loadingState').classList.add('d-none');
        document.getElementById('errorState').classList.remove('d-none');
        document.getElementById('errorMessage').textContent = error.message;
    }
}

async function loadVerificationTable() {
    const location = 'Fairfax, VA';
    const period = document.getElementById('fairfaxPeriodToggle')?.checked ? 'monthly' : 'all';
    try {
        const response = await fetch(`/api/verification-by-lead-time?location=${encodeURIComponent(location)}&period=${period}`);
        const data = await response.json();
        if (data.success && data.verification.lead_times.length > 0) {
            renderVerificationTable(data.verification);
            document.getElementById('verificationSection').style.display = '';
        } else {
            const tbody = document.getElementById('verificationTableBody');
            tbody.innerHTML = '<tr><td colspan="18" class="text-center text-muted">No verification data available yet. Sync forecasts and wait for observations.</td></tr>';
            document.getElementById('verificationSection').style.display = '';
        }
    } catch (error) {
        console.error('Error loading verification table:', error);
        const tbody = document.getElementById('verificationTableBody');
        tbody.innerHTML = '<tr><td colspan="18" class="text-center text-muted">Unable to load verification data.</td></tr>';
        document.getElementById('verificationSection').style.display = '';
    }
}

// Update the "fetched at" time display
function updateFetchedTime(data) {
    if (data.fetched_at) {
        const fetchedAt = new Date(data.fetched_at);
        const timeStr = fetchedAt.toLocaleString('en-US', {
            month: 'short',
            day: 'numeric',
            hour: 'numeric',
            minute: '2-digit',
            hour12: true
        });
        // Add fetched time to the header if element exists
        const header = document.querySelector('.forecast-header p');
        if (header) {
            header.innerHTML = `GFS vs ECMWF AIFS vs ECMWF IFS model forecasts <span class="opacity-75">| Data from ${timeStr}</span>`;
        }
    }
}

// Update summary stats (removed - stats cards no longer displayed)

// Update init times
function updateInitTimes(data) {
    if (data.gfs.init_time) {
        const gfsInit = new Date(data.gfs.init_time);
        document.getElementById('gfsInitTime').textContent =
            'GFS: ' + gfsInit.toLocaleString('en-US', { month: 'short', day: 'numeric', hour: '2-digit', hour12: false, timeZone: 'UTC' }) + 'Z';
    }
    if (data.aifs.init_time) {
        const aifsInit = new Date(data.aifs.init_time);
        document.getElementById('aifsInitTime').textContent =
            'AIFS/IFS: ' + aifsInit.toLocaleString('en-US', { month: 'short', day: 'numeric', hour: '2-digit', hour12: false, timeZone: 'UTC' }) + 'Z';
    }
}

// Update observed legend visibility
function updateObservedLegend(data) {
    const hasObserved = data.observed && data.observed.temps && data.observed.temps.some(t => t !== null);
    document.getElementById('observedLegend').style.display = hasObserved ? '' : 'none';
}

// Format lead time for display
function formatLeadTime(hours) {
    if (hours < 24) {
        return hours + 'h';
    }
    const days = Math.floor(hours / 24);
    const remainingHours = hours % 24;
    if (remainingHours === 0) {
        return days + 'd';
    }
    return days + 'd ' + remainingHours + 'h';
}

// Render verification table with accumulated data across all runs
function renderVerificationTable(v) {
    const tbody = document.getElementById('verificationTableBody');
    tbody.innerHTML = '';

    const ifsTempMae = v.ifs_temp_mae || [];
    const ifsMslpMae = v.ifs_mslp_mae || [];

    for (let i = 0; i < v.lead_times.length; i++) {
        const lt = v.lead_times[i];
        const days = v.lead_times_days[i];

        // Temperature data
        const gfsTempMae = v.gfs_temp_mae[i];
        const gfsTempBias = v.gfs_temp_bias[i];
        const aifsTempMae = v.aifs_temp_mae[i];
        const aifsTempBias = v.aifs_temp_bias[i];
        const ifsTempMaeVal = ifsTempMae[i];
        const ifsTempBias = v.ifs_temp_bias ? v.ifs_temp_bias[i] : null;
        const nwsTempMae = v.nws_temp_mae ? v.nws_temp_mae[i] : null;
        const nwsTempBias = v.nws_temp_bias ? v.nws_temp_bias[i] : null;

        // Pressure data
        const gfsMslpMae = v.gfs_mslp_mae[i];
        const gfsMslpBias = v.gfs_mslp_bias[i];
        const aifsMslpMae = v.aifs_mslp_mae[i];
        const aifsMslpBias = v.aifs_mslp_bias[i];
        const ifsMslpMaeVal = ifsMslpMae[i];
        const ifsMslpBias = v.ifs_mslp_bias ? v.ifs_mslp_bias[i] : null;

        const samples = v.temp_sample_counts[i];

        // Determine winner - find lowest MAE among all models
        let winner = '--';
        let winnerClass = 'badge bg-secondary';
        const tempMaes = [
            { name: 'GFS', mae: gfsTempMae, class: 'badge bg-danger' },
            { name: 'AIFS', mae: aifsTempMae, class: 'badge bg-warning text-dark' },
            { name: 'IFS', mae: ifsTempMaeVal, class: 'badge bg-success' },
            { name: 'NWS', mae: nwsTempMae, class: 'badge bg-dark' }
        ].filter(m => m.mae !== null && m.mae !== undefined);

        if (tempMaes.length > 0) {
            const minMae = Math.min(...tempMaes.map(m => m.mae));
            const winners = tempMaes.filter(m => m.mae === minMae);
            if (winners.length === 1) {
                winner = winners[0].name;
                winnerClass = winners[0].class;
            } else {
                winner = 'Tie';
                winnerClass = 'badge bg-secondary';
            }
        }

        const row = document.createElement('tr');
        row.innerHTML = `
            <td><strong>${formatLeadTime(lt)}</strong></td>
            <td>${days.toFixed(1)}</td>
            <td class="text-center">${gfsTempMae !== null ? gfsTempMae.toFixed(1) + '°F' : '--'}</td>
            <td class="text-center">${gfsTempBias !== null ? (gfsTempBias > 0 ? '+' : '') + gfsTempBias.toFixed(1) + '°F' : '--'}</td>
            <td class="text-center">${aifsTempMae !== null ? aifsTempMae.toFixed(1) + '°F' : '--'}</td>
            <td class="text-center">${aifsTempBias !== null ? (aifsTempBias > 0 ? '+' : '') + aifsTempBias.toFixed(1) + '°F' : '--'}</td>
            <td class="text-center">${ifsTempMaeVal !== null && ifsTempMaeVal !== undefined ? ifsTempMaeVal.toFixed(1) + '°F' : '--'}</td>
            <td class="text-center">${ifsTempBias !== null && ifsTempBias !== undefined ? (ifsTempBias > 0 ? '+' : '') + ifsTempBias.toFixed(1) + '°F' : '--'}</td>
            <td class="text-center">${nwsTempMae !== null && nwsTempMae !== undefined ? nwsTempMae.toFixed(1) + '°F' : '--'}</td>
            <td class="text-center">${nwsTempBias !== null && nwsTempBias !== undefined ? (nwsTempBias > 0 ? '+' : '') + nwsTempBias.toFixed(1) + '°F' : '--'}</td>
            <td><span class="${winnerClass}">${winner}</span></td>
            <td class="text-center">${gfsMslpMae !== null ? gfsMslpMae.toFixed(1) + ' mb' : '--'}</td>
            <td class="text-center">${gfsMslpBias !== null ? (gfsMslpBias > 0 ? '+' : '') + gfsMslpBias.toFixed(1) + ' mb' : '--'}</td>
            <td class="text-center">${aifsMslpMae !== null ? aifsMslpMae.toFixed(1) + ' mb' : '--'}</td>
            <td class="text-center">${aifsMslpBias !== null ? (aifsMslpBias > 0 ? '+' : '') + aifsMslpBias.toFixed(1) + ' mb' : '--'}</td>
            <td class="text-center">${ifsMslpMaeVal !== null && ifsMslpMaeVal !== undefined ? ifsMslpMaeVal.toFixed(1) + ' mb' : '--'}</td>
            <td class="text-center">${ifsMslpBias !== null && ifsMslpBias !== undefined ? (ifsMslpBias > 0 ? '+' : '') + ifsMslpBias.toFixed(1) + ' mb' : '--'}</td>
            <td>${samples}</td>
        `;
        tbody.appendChild(row);
    }
}

// Render temperature chart only
function renderTempChart(data, tempHistoryData, panguData, nwsData) {
    // Convert forecast data to {x, y} format
    const gfsData = data.gfs.times.map((t, i) => ({ x: new Date(t), y: data.gfs.temps[i] }));
    const aifsData = data.aifs.times.map((t, i) => ({ x: new Date(t), y: data.aifs.temps[i] }));
    const ifsData = data.ifs ? data.ifs.times.map((t, i) => ({ x: new Date(t), y: data.ifs.temps[i] })) : [];

    // Calculate x-axis range
    const allTimes = [...data.gfs.times, ...data.aifs.times];
    if (data.ifs && data.ifs.times) {
        allTimes.push(...data.ifs.times);
    }
    if (tempHistoryData && tempHistoryData.dates) {
        allTimes.push(...tempHistoryData.dates);
    }
    if (panguData && panguData.times) {
        allTimes.push(...panguData.times);
    }
    if (nwsData && nwsData.forecast) {
        allTimes.push(...nwsData.forecast.map(f => f.datetime));
    }

    const allDates = allTimes
        .filter(t => t != null)
        .map(t => new Date(t))
        .filter(d => !isNaN(d.getTime()));

    const minDate = allDates.length > 0 ? new Date(Math.min(...allDates)) : null;
    const maxDate = allDates.length > 0 ? new Date(Math.max(...allDates)) : null;

    // Build x-axis configuration
    const xAxisConfig = {
        type: 'time',
        time: {
            unit: 'day',
            displayFormats: { day: 'MMM d' },
            tooltipFormat: 'MMM d, ha'
        },
        grid: { display: false },
        ticks: {
            maxRotation: 45,
            minRotation: 45
        }
    };
    if (minDate && maxDate) {
        xAxisConfig.min = minDate;
        xAxisConfig.max = maxDate;
    }

    // Temperature chart datasets
    const tempDatasets = [];

    // Add historical observed line with points and bias bars if available
    if (tempHistoryData && tempHistoryData.dates && tempHistoryData.observed) {
        const historicalObserved = tempHistoryData.dates.map((d, i) => ({
            x: new Date(d),
            y: tempHistoryData.observed[i]
        }));

        tempDatasets.push({
            label: 'Observed (Historical)',
            data: historicalObserved,
            type: 'line',
            borderColor: '#000000',
            backgroundColor: 'rgba(0, 0, 0, 0.1)',
            borderWidth: 2.5,
            pointRadius: 4,
            pointHoverRadius: 6,
            pointBackgroundColor: '#000000',
            tension: 0.3,
            order: 0,
            spanGaps: true
        });

    }

    // Add forecast lines
    tempDatasets.push({
        label: 'GFS Forecast',
        data: gfsData,
        type: 'line',
        borderColor: '#0d6efd',
        backgroundColor: 'rgba(13, 110, 253, 0.1)',
        fill: false,
        tension: 0.3,
        pointRadius: 0,
        pointHoverRadius: 5,
        borderWidth: 1.5,
        order: 1
    });

    tempDatasets.push({
        label: 'AIFS Forecast',
        data: aifsData,
        type: 'line',
        borderColor: '#0dcaf0',
        backgroundColor: 'rgba(13, 202, 240, 0.1)',
        fill: false,
        tension: 0.3,
        pointRadius: 0,
        pointHoverRadius: 5,
        borderWidth: 1.5,
        borderDash: [5, 5],
        order: 2
    });

    if (data.ifs && data.ifs.temps) {
        tempDatasets.push({
            label: 'IFS Forecast',
            data: ifsData,
            type: 'line',
            borderColor: '#20c997',
            backgroundColor: 'rgba(32, 201, 151, 0.1)',
            fill: false,
            tension: 0.3,
            pointRadius: 0,
            pointHoverRadius: 5,
            borderWidth: 1.5,
            borderDash: [2, 2],
            order: 3
        });
    }

    if (panguData && panguData.times && panguData.temp_surface) {
        const panguSeries = panguData.times.map((t, i) => ({
            x: new Date(t),
            y: panguData.temp_surface[i]
        }));
        tempDatasets.push({
            label: 'Pangu Forecast',
            data: panguSeries,
            type: 'line',
            borderColor: '#7c3aed',
            backgroundColor: 'rgba(124, 58, 237, 0.08)',
            fill: false,
            tension: 0.3,
            pointRadius: 0,
            pointHoverRadius: 5,
            borderWidth: 2,
            order: 2
        });
    }

    if (nwsData && nwsData.forecast) {
        const nwsSeries = nwsData.forecast.map(f => ({
            x: new Date(f.datetime),
            y: f.temperature
        }));
        tempDatasets.push({
            label: 'NWS Forecast',
            data: nwsSeries,
            type: 'line',
            borderColor: '#000000',
            backgroundColor: 'rgba(0, 0, 0, 0.0)',
            fill: false,
            tension: 0.25,
            pointRadius: 0,
            pointHoverRadius: 5,
            borderWidth: 4,
            borderDash: [8, 6],
            order: 0
        });
    }

    // Calculate y-axis range
    let tempMin = Infinity;
    let tempMax = -Infinity;

    tempDatasets.forEach(dataset => {
        dataset.data.forEach(point => {
            if (!point) return;
            if (Array.isArray(point.y)) {
                const [min, max] = point.y;
                tempMin = Math.min(tempMin, min, max);
                tempMax = Math.max(tempMax, min, max);
            } else if (point.y !== null && point.y !== undefined) {
                tempMin = Math.min(tempMin, point.y);
                tempMax = Math.max(tempMax, point.y);
            }
        });
    });

    const tempRange = tempMax - tempMin;
    const tempPadding = tempRange * 0.1;
    const tempYMin = tempMin - tempPadding;
    const tempYMax = tempMax + tempPadding;

    // Anchor points to keep tooltip active across the full x-range
    const uniqueTimes = [...new Set(allDates.map(d => d.getTime()))].sort((a, b) => a - b);
    const anchorY = isFinite(tempYMin) && isFinite(tempYMax)
        ? tempYMin + (tempYMax - tempYMin) * 0.02
        : 0;
    const anchorData = uniqueTimes.map(ts => ({ x: new Date(ts), y: anchorY }));
    tempDatasets.push({
        label: 'Hover Anchor',
        data: anchorData,
        type: 'line',
        borderColor: 'rgba(0,0,0,0)',
        backgroundColor: 'rgba(0,0,0,0)',
        pointRadius: 0,
        pointHoverRadius: 0,
        pointHitRadius: 60,
        showLine: false,
        order: 99
    });

    // Render temperature chart
    if (tempChart) tempChart.destroy();
    tempChart = new Chart(document.getElementById('tempChart'), {
        type: 'bar',
        data: { datasets: tempDatasets },
        options: {
            responsive: true,
            maintainAspectRatio: false,
            interaction: {
                mode: 'x',
                intersect: false,
                axis: 'x',
                radius: 120
            },
            hover: {
                mode: 'x',
                intersect: false,
                axis: 'x'
            },
            plugins: {
                legend: {
                    position: 'top',
                    labels: {
                        usePointStyle: true,
                        padding: 15,
                        filter: function(item) {
                            return item.text !== 'Hover Anchor';
                        }
                    }
                },
                tooltip: {
                    mode: 'x',
                    intersect: false,
                    filter: function(tooltipItem) {
                        const hasData = tooltipItem.parsed.y !== null && tooltipItem.parsed.y !== undefined;
                        if (!hasData) return false;
                        const label = tooltipItem.dataset.label;
                        return label === 'Hover Anchor' || label.includes('Observed') || label.includes('Forecast') || label.includes('Pangu');
                    },
                    callbacks: {
                        label: function(context) {
                            const label = context.dataset.label || '';
                            if (label === 'Hover Anchor') {
                                return `Time: ${context.label}`;
                            }
                            const value = context.parsed.y;
                            return label + ': ' +
                                (value !== null && value !== undefined ? value.toFixed(1) + '°F' : 'N/A');
                        }
                    }
                }
            },
            scales: {
                y: {
                    min: isFinite(tempYMin) ? tempYMin : undefined,
                    max: isFinite(tempYMax) ? tempYMax : undefined,
                    grid: { color: '#e0e0e0' },
                    title: { display: true, text: 'Temperature (°F)' }
                },
                x: xAxisConfig
            }
        }
    });

    // Render bias panel chart
    if (tempBiasPanelChart) tempBiasPanelChart.destroy();
    const biasLabels = tempHistoryData && tempHistoryData.dates
        ? tempHistoryData.dates.map(d => new Date(d))
        : [];
    const biasDatasets = [];
    if (tempHistoryData && tempHistoryData.dates) {
        biasDatasets.push({
            label: 'GFS Bias',
            data: tempHistoryData.dates.map((d, i) => ({
                x: new Date(d),
                y: tempHistoryData.gfs_bias[i]
            })),
            backgroundColor: 'rgba(13, 110, 253, 0.7)',
            borderColor: '#0d6efd',
            borderWidth: 1
        });
        biasDatasets.push({
            label: 'AIFS Bias',
            data: tempHistoryData.dates.map((d, i) => ({
                x: new Date(d),
                y: tempHistoryData.aifs_bias[i]
            })),
            backgroundColor: 'rgba(13, 202, 240, 0.7)',
            borderColor: '#0dcaf0',
            borderWidth: 1
        });
        biasDatasets.push({
            label: 'IFS Bias',
            data: tempHistoryData.dates.map((d, i) => ({
                x: new Date(d),
                y: tempHistoryData.ifs_bias[i]
            })),
            backgroundColor: 'rgba(32, 201, 151, 0.7)',
            borderColor: '#20c997',
            borderWidth: 1
        });
    }

    tempBiasPanelChart = new Chart(document.getElementById('tempBiasChart'), {
        type: 'bar',
        data: { datasets: biasDatasets },
        options: {
            responsive: true,
            maintainAspectRatio: false,
            interaction: {
                mode: 'x',
                intersect: false,
                axis: 'x',
                radius: 120
            },
            plugins: {
                legend: { position: 'top' },
                tooltip: {
                    mode: 'x',
                    intersect: false,
                    callbacks: {
                        label: function(context) {
                            const label = context.dataset.label || '';
                            const value = context.parsed.y;
                            return label + ': ' +
                                (value !== null && value !== undefined ? (value > 0 ? '+' : '') + value.toFixed(2) + '°F' : 'N/A');
                        }
                    }
                }
            },
            scales: {
                y: {
                    grid: { color: '#e0e0e0' },
                    title: { display: true, text: 'Bias (°F)' },
                    beginAtZero: true
                },
                x: xAxisConfig
            }
        }
    });
}

// Render MSLP chart only
function renderMslpChart(data, mslpHistoryData, panguData) {
    // Convert forecast data to {x, y} format
    const gfsMslpData = data.gfs.times.map((t, i) => ({ x: new Date(t), y: data.gfs.mslps[i] }));
    const aifsMslpData = data.aifs.times.map((t, i) => ({ x: new Date(t), y: data.aifs.mslps[i] }));
    const ifsMslpData = data.ifs ? data.ifs.times.map((t, i) => ({ x: new Date(t), y: data.ifs.mslps[i] })) : [];

    // Calculate x-axis range
    const allTimes = [...data.gfs.times, ...data.aifs.times];
    if (data.ifs && data.ifs.times) {
        allTimes.push(...data.ifs.times);
    }
    if (mslpHistoryData && mslpHistoryData.dates) {
        allTimes.push(...mslpHistoryData.dates);
    }
    if (panguData && panguData.times) {
        allTimes.push(...panguData.times);
    }

    const allDates = allTimes
        .filter(t => t != null)
        .map(t => new Date(t))
        .filter(d => !isNaN(d.getTime()));

    const minDate = allDates.length > 0 ? new Date(Math.min(...allDates)) : null;
    const maxDate = allDates.length > 0 ? new Date(Math.max(...allDates)) : null;

    // Build x-axis configuration
    const xAxisConfig = {
        type: 'time',
        time: {
            unit: 'day',
            displayFormats: { day: 'MMM d' },
            tooltipFormat: 'MMM d, ha'
        },
        grid: { display: false },
        ticks: {
            maxRotation: 45,
            minRotation: 45
        }
    };
    if (minDate && maxDate) {
        xAxisConfig.min = minDate;
        xAxisConfig.max = maxDate;
    }

    // MSLP chart datasets
    const mslpDatasets = [];

    // Add historical observed line with points and bias bars if available
    if (mslpHistoryData && mslpHistoryData.dates && mslpHistoryData.observed) {
        const historicalObservedMslp = mslpHistoryData.dates.map((d, i) => ({
            x: new Date(d),
            y: mslpHistoryData.observed[i]
        }));

        mslpDatasets.push({
            label: 'Observed (Historical)',
            data: historicalObservedMslp,
            type: 'line',
            borderColor: '#000000',
            backgroundColor: 'rgba(0, 0, 0, 0.1)',
            borderWidth: 2.5,
            pointRadius: 4,
            pointHoverRadius: 6,
            pointBackgroundColor: '#000000',
            tension: 0.3,
            order: 0,
            spanGaps: true
        });

    }

    // Add forecast lines
    mslpDatasets.push({
        label: 'GFS Forecast',
        data: gfsMslpData,
        type: 'line',
        borderColor: '#0d6efd',
        backgroundColor: 'rgba(13, 110, 253, 0.1)',
        fill: false,
        tension: 0.3,
        pointRadius: 0,
        pointHoverRadius: 5,
        borderWidth: 2,
        order: 1
    });

    mslpDatasets.push({
        label: 'AIFS Forecast',
        data: aifsMslpData,
        type: 'line',
        borderColor: '#0dcaf0',
        backgroundColor: 'rgba(13, 202, 240, 0.1)',
        fill: false,
        tension: 0.3,
        pointRadius: 0,
        pointHoverRadius: 5,
        borderWidth: 2,
        borderDash: [5, 5],
        order: 2
    });

    if (data.ifs && data.ifs.mslps) {
        mslpDatasets.push({
            label: 'IFS Forecast',
            data: ifsMslpData,
            type: 'line',
            borderColor: '#20c997',
            backgroundColor: 'rgba(32, 201, 151, 0.1)',
            fill: false,
            tension: 0.3,
            pointRadius: 0,
            pointHoverRadius: 5,
            borderWidth: 2,
            borderDash: [2, 2],
            order: 3
        });
    }

    if (panguData && panguData.times && panguData.pressure_msl) {
        const panguSeries = panguData.times.map((t, i) => ({
            x: new Date(t),
            y: panguData.pressure_msl[i]
        }));
        mslpDatasets.push({
            label: 'Pangu Forecast',
            data: panguSeries,
            type: 'line',
            borderColor: '#7c3aed',
            backgroundColor: 'rgba(124, 58, 237, 0.08)',
            fill: false,
            tension: 0.3,
            pointRadius: 0,
            pointHoverRadius: 5,
            borderWidth: 3,
            order: 2
        });
    }

    // Calculate y-axis range
    let mslpMin = Infinity;
    let mslpMax = -Infinity;

    mslpDatasets.forEach(dataset => {
        dataset.data.forEach(point => {
            if (!point) return;
            if (Array.isArray(point.y)) {
                const [min, max] = point.y;
                mslpMin = Math.min(mslpMin, min, max);
                mslpMax = Math.max(mslpMax, min, max);
            } else if (point.y !== null && point.y !== undefined) {
                mslpMin = Math.min(mslpMin, point.y);
                mslpMax = Math.max(mslpMax, point.y);
            }
        });
    });

    const mslpRange = mslpMax - mslpMin;
    const mslpPadding = mslpRange * 0.1;
    const mslpYMin = mslpMin - mslpPadding;
    const mslpYMax = mslpMax + mslpPadding;

    // Anchor points to keep tooltip active across the full x-range
    const mslpAllDates = allDates;
    const mslpUniqueTimes = [...new Set(mslpAllDates.map(d => d.getTime()))].sort((a, b) => a - b);
    const mslpAnchorY = isFinite(mslpYMin) && isFinite(mslpYMax)
        ? mslpYMin + (mslpYMax - mslpYMin) * 0.02
        : 0;
    const mslpAnchorData = mslpUniqueTimes.map(ts => ({ x: new Date(ts), y: mslpAnchorY }));
    mslpDatasets.push({
        label: 'Hover Anchor',
        data: mslpAnchorData,
        type: 'line',
        borderColor: 'rgba(0,0,0,0)',
        backgroundColor: 'rgba(0,0,0,0)',
        pointRadius: 0,
        pointHoverRadius: 0,
        pointHitRadius: 60,
        showLine: false,
        order: 99
    });

    // Render MSLP chart
    if (mslpChart) mslpChart.destroy();
    mslpChart = new Chart(document.getElementById('mslpChart'), {
        type: 'bar',
        data: { datasets: mslpDatasets },
        options: {
            responsive: true,
            maintainAspectRatio: false,
            interaction: {
                mode: 'x',
                intersect: false,
                axis: 'x',
                radius: 120
            },
            hover: {
                mode: 'x',
                intersect: false,
                axis: 'x'
            },
            plugins: {
                legend: {
                    position: 'top',
                    labels: {
                        usePointStyle: true,
                        padding: 15,
                        filter: function(item) {
                            return item.text !== 'Hover Anchor';
                        }
                    }
                },
                tooltip: {
                    mode: 'x',
                    intersect: false,
                    filter: function(tooltipItem) {
                        const hasData = tooltipItem.parsed.y !== null && tooltipItem.parsed.y !== undefined;
                        if (!hasData) return false;
                        const label = tooltipItem.dataset.label;
                        return label === 'Hover Anchor' || label.includes('Observed') || label.includes('Forecast') || label.includes('Pangu');
                    },
                    callbacks: {
                        label: function(context) {
                            const label = context.dataset.label || '';
                            if (label === 'Hover Anchor') {
                                return `Time: ${context.label}`;
                            }
                            const value = context.parsed.y;
                            return label + ': ' +
                                (value !== null && value !== undefined ? value.toFixed(1) + ' mb' : 'N/A');
                        }
                    }
                }
            },
            scales: {
                y: {
                    min: isFinite(mslpYMin) ? mslpYMin : undefined,
                    max: isFinite(mslpYMax) ? mslpYMax : undefined,
                    grid: { color: '#e0e0e0' },
                    title: { display: true, text: 'Pressure (mb)' }
                },
                x: xAxisConfig
            }
        }
    });

    // Render bias panel chart
    if (mslpBiasPanelChart) mslpBiasPanelChart.destroy();
    const mslpBiasDatasets = [];
    if (mslpHistoryData && mslpHistoryData.dates) {
        mslpBiasDatasets.push({
            label: 'GFS Bias',
            data: mslpHistoryData.dates.map((d, i) => ({
                x: new Date(d),
                y: mslpHistoryData.gfs_bias[i]
            })),
            backgroundColor: 'rgba(13, 110, 253, 0.7)',
            borderColor: '#0d6efd',
            borderWidth: 1
        });
        mslpBiasDatasets.push({
            label: 'AIFS Bias',
            data: mslpHistoryData.dates.map((d, i) => ({
                x: new Date(d),
                y: mslpHistoryData.aifs_bias[i]
            })),
            backgroundColor: 'rgba(13, 202, 240, 0.7)',
            borderColor: '#0dcaf0',
            borderWidth: 1
        });
        mslpBiasDatasets.push({
            label: 'IFS Bias',
            data: mslpHistoryData.dates.map((d, i) => ({
                x: new Date(d),
                y: mslpHistoryData.ifs_bias[i]
            })),
            backgroundColor: 'rgba(32, 201, 151, 0.7)',
            borderColor: '#20c997',
            borderWidth: 1
        });
    }

    mslpBiasPanelChart = new Chart(document.getElementById('mslpBiasChart'), {
        type: 'bar',
        data: { datasets: mslpBiasDatasets },
        options: {
            responsive: true,
            maintainAspectRatio: false,
            interaction: {
                mode: 'x',
                intersect: false,
                axis: 'x',
                radius: 120
            },
            plugins: {
                legend: { position: 'top' },
                tooltip: {
                    mode: 'x',
                    intersect: false,
                    callbacks: {
                        label: function(context) {
                            const label = context.dataset.label || '';
                            const value = context.parsed.y;
                            return label + ': ' +
                                (value !== null && value !== undefined ? (value > 0 ? '+' : '') + value.toFixed(2) + ' mb' : 'N/A');
                        }
                    }
                }
            },
            scales: {
                y: {
                    grid: { color: '#e0e0e0' },
                    title: { display: true, text: 'Bias (mb)' },
                    beginAtZero: true
                },
                x: xAxisConfig
            }
        }
    });
}

// Render charts
function renderForecastCharts(data, tempHistoryData, mslpHistoryData, precipHistoryData, panguData, nwsData) {
    // Render temperature and MSLP charts using dedicated functions
    renderTempChart(data, tempHistoryData, panguData, nwsData);
    renderMslpChart(data, mslpHistoryData, panguData);

    // Render daily precipitation chart
    renderPrecipChart(precipHistoryData);
}

function renderPrecipChart(precipHistoryData) {
    if (!precipHistoryData || !precipHistoryData.dates) {
        if (precipChart) precipChart.destroy();
        if (precipBiasPanelChart) precipBiasPanelChart.destroy();
        return;
    }

    const dates = precipHistoryData.dates.map(d => new Date(d));
    const observed = precipHistoryData.observed || [];
    const gfs = precipHistoryData.gfs || [];
    const aifs = precipHistoryData.aifs || [];
    const ifs = precipHistoryData.ifs || [];
    const gfsBias = precipHistoryData.gfs_bias || [];
    const aifsBias = precipHistoryData.aifs_bias || [];
    const ifsBias = precipHistoryData.ifs_bias || [];

    // Winner tally based on lowest absolute bias
    const precipTallyEl = document.getElementById('precipWinnerTally');
    if (precipTallyEl && dates.length) {
        let gfsWins = 0;
        let aifsWins = 0;
        let ifsWins = 0;
        let tieWins = 0;

        for (let i = 0; i < dates.length; i++) {
            const candidates = [];
            const g = gfsBias[i];
            const a = aifsBias[i];
            const f = ifsBias[i];

            if (g !== null && g !== undefined) candidates.push({ key: 'gfs', val: Math.abs(g) });
            if (a !== null && a !== undefined) candidates.push({ key: 'aifs', val: Math.abs(a) });
            if (f !== null && f !== undefined) candidates.push({ key: 'ifs', val: Math.abs(f) });

            if (candidates.length === 0) continue;
            const minVal = Math.min(...candidates.map(c => c.val));
            const winners = candidates.filter(c => c.val === minVal);

            if (winners.length === 1) {
                const w = winners[0].key;
                if (w === 'gfs') gfsWins += 1;
                else if (w === 'aifs') aifsWins += 1;
                else if (w === 'ifs') ifsWins += 1;
            } else {
                tieWins += 1;
            }
        }

        document.getElementById('precipGfsWins').textContent = gfsWins;
        document.getElementById('precipAifsWins').textContent = aifsWins;
        document.getElementById('precipIfsWins').textContent = ifsWins;
        document.getElementById('precipTieWins').textContent = tieWins;
        precipTallyEl.classList.remove('d-none');
    } else if (precipTallyEl) {
        precipTallyEl.classList.add('d-none');
    }

    const precipDatasets = [
        {
            label: 'Observed (CoCoRaHS)',
            data: dates.map((d, i) => ({ x: d, y: observed[i] })),
            borderColor: '#000000',
            backgroundColor: 'rgba(0,0,0,0.08)',
            fill: false,
            tension: 0.25,
            pointRadius: 3,
            pointHoverRadius: 5,
            borderWidth: 2
        },
        {
            label: 'GFS Daily',
            data: dates.map((d, i) => ({ x: d, y: gfs[i] })),
            borderColor: '#0d6efd',
            backgroundColor: 'rgba(13, 110, 253, 0.1)',
            fill: false,
            tension: 0.25,
            pointRadius: 2,
            pointHoverRadius: 4,
            borderWidth: 2
        },
        {
            label: 'AIFS Daily',
            data: dates.map((d, i) => ({ x: d, y: aifs[i] })),
            borderColor: '#0dcaf0',
            backgroundColor: 'rgba(13, 202, 240, 0.1)',
            fill: false,
            tension: 0.25,
            pointRadius: 2,
            pointHoverRadius: 4,
            borderWidth: 2,
            borderDash: [5, 5]
        }
    ];

    if (ifs && ifs.length) {
        precipDatasets.push({
            label: 'IFS Daily',
            data: dates.map((d, i) => ({ x: d, y: ifs[i] })),
            borderColor: '#20c997',
            backgroundColor: 'rgba(32, 201, 151, 0.1)',
            fill: false,
            tension: 0.25,
            pointRadius: 2,
            pointHoverRadius: 4,
            borderWidth: 2,
            borderDash: [2, 2]
        });
    }

    const xAxisConfig = {
        type: 'time',
        time: {
            unit: 'day',
            displayFormats: { day: 'MMM d' }
        },
        grid: { display: false },
        ticks: {
            maxRotation: 45,
            minRotation: 45
        }
    };

    if (precipChart) precipChart.destroy();
    precipChart = new Chart(document.getElementById('precipChart'), {
        type: 'line',
        data: { datasets: precipDatasets },
        options: {
            responsive: true,
            maintainAspectRatio: false,
            interaction: {
                mode: 'x',
                intersect: false
            },
            plugins: {
                legend: {
                    position: 'top',
                    labels: {
                        usePointStyle: true,
                        padding: 20
                    }
                },
                tooltip: {
                    mode: 'x',
                    intersect: false,
                    callbacks: {
                        label: function(context) {
                            const value = context.parsed.y;
                            return context.dataset.label + ': ' +
                                (value !== null && value !== undefined ? value.toFixed(2) + ' in' : 'N/A');
                        }
                    }
                }
            },
            scales: {
                y: {
                    beginAtZero: true,
                    grid: { color: '#e0e0e0' },
                    title: { display: true, text: 'Daily Precipitation (in)' }
                },
                x: xAxisConfig
            }
        }
    });

    // Render precipitation bias panel (model - observed)
    const biasDatasets = [
        {
            label: 'GFS Bias',
            data: dates.map((d, i) => ({
                x: d,
                y: gfsBias[i] ?? null
            })),
            backgroundColor: 'rgba(13, 110, 253, 0.7)',
            borderColor: '#0d6efd',
            borderWidth: 1
        },
        {
            label: 'AIFS Bias',
            data: dates.map((d, i) => ({
                x: d,
                y: aifsBias[i] ?? null
            })),
            backgroundColor: 'rgba(13, 202, 240, 0.7)',
            borderColor: '#0dcaf0',
            borderWidth: 1
        }
    ];

    if (ifs && ifs.length) {
        biasDatasets.push({
            label: 'IFS Bias',
            data: dates.map((d, i) => ({
                x: d,
                y: ifsBias[i] ?? null
            })),
            backgroundColor: 'rgba(32, 201, 151, 0.7)',
            borderColor: '#20c997',
            borderWidth: 1
        });
    }

    if (precipBiasPanelChart) precipBiasPanelChart.destroy();
    precipBiasPanelChart = new Chart(document.getElementById('precipBiasChart'), {
        type: 'bar',
        data: { datasets: biasDatasets },
        options: {
            responsive: true,
            maintainAspectRatio: false,
            interaction: {
                mode: 'x',
                intersect: false,
                axis: 'x',
                radius: 120
            },
            plugins: {
                legend: { position: 'top' },
                tooltip: {
                    mode: 'x',
                    intersect: false,
                    callbacks: {
                        label: function(context) {
                            const label = context.dataset.label || '';
                            const value = context.parsed.y;
                            return label + ': ' +
                                (value !== null && value !== undefined ? (value > 0 ? '+' : '') + value.toFixed(2) + ' in' : 'N/A');
                        }
                    }
                }
            },
            scales: {
                y: {
                    grid: { color: '#e0e0e0' },
                    title: { display: true, text: 'Bias (in)' },
                    beginAtZero: true
                },
                x: xAxisConfig
            }
        }
    });
}

let tempMaeChart, tempBiasChart, mslpMaeChart, mslpBiasChart;
let tempChart, precipChart, mslpChart, tempBiasPanelChart, mslpBiasPanelChart, precipBiasPanelChart;

// ============================================================================
// Existing Verification Functionality
// ============================================================================

// Format lead time for display
function formatLeadTime(hours) {
    if (hours < 24) {
        return hours + 'h';
    }
    const days = Math.floor(hours / 24);
    const remainingHours = hours % 24;
    if (remainingHours === 0) {
        return days + 'd';
    }
    return days + 'd ' + remainingHours + 'h';
}

// Load verification data
async function loadLeadTimeVerification() {
    const location = 'Fairfax, VA';
    const period = document.getElementById('fairfaxPeriodToggle')?.checked ? 'monthly' : 'all';

    document.getElementById('loadingState').classList.remove('d-none');
    document.getElementById('verificationContent').classList.add('d-none');
    document.getElementById('errorState').classList.add('d-none');

    try {
        const [verificationResponse, runsResponse] = await Promise.all([
            fetch(`/api/verification-by-lead-time?location=${encodeURIComponent(location)}&period=${period}`),
            fetch(`/api/runs?location=${encodeURIComponent(location)}`)
        ]);

        const verificationData = await verificationResponse.json();
        const runsData = await runsResponse.json();

        if (!verificationData.success) {
            throw new Error(verificationData.error || 'No verification data available');
        }

        const v = verificationData.verification;

        if (!v.lead_times || v.lead_times.length === 0) {
            throw new Error('No verified forecast data yet. Sync forecasts and wait for observations.');
        }

        document.getElementById('loadingState').classList.add('d-none');
        document.getElementById('verificationContent').classList.remove('d-none');

        updateVerificationSummaryStats(v);
        // renderVerificationCharts removed - charts deleted
        // renderVerificationTable call removed - second table deleted

        if (runsData.success) {
            renderRunsTable(runsData.runs);
        }

    } catch (error) {
        console.error('Error loading verification:', error);
        document.getElementById('loadingState').classList.add('d-none');
        document.getElementById('errorState').classList.remove('d-none');
        document.getElementById('errorMessage').textContent = error.message;
    }
}

// Update summary statistics
function updateVerificationSummaryStats(v) {
    const totalRunsEl = document.getElementById('totalRuns');
    if (totalRunsEl) {
        totalRunsEl.textContent = v.run_count || '--';
    }
    // Removed references to deleted stat cards (maxLeadTime, gfsAvgMae, aifsAvgMae, ifsAvgMae)
}

// Render charts function removed - charts deleted from UI

function getVerificationChartOptions(yLabel, minY = null, showZeroLine = false) {
    const options = {
        responsive: true,
        maintainAspectRatio: false,
        interaction: {
            mode: 'index',
            intersect: false
        },
        plugins: {
            legend: {
                position: 'top',
                labels: {
                    usePointStyle: true,
                    padding: 20
                }
            },
            annotation: { // Add this if you don't have it already
                annotations: {}
            }
        },
        scales: {
            y: {
                grid: { color: '#e0e0e0' },
                title: { display: true, text: yLabel }
            },
            x: {
                grid: { display: false },
                title: { display: true, text: 'Lead Time' }
            }
        }
    };

    if (minY !== null) {
        options.scales.y.min = minY;
    }

    if (showZeroLine) {
        options.plugins.annotation = {
            annotations: {
                zeroLine: {
                    type: 'line',
                    yMin: 0,
                    yMax: 0,
                    borderColor: '#999',
                    borderWidth: 1,
                    borderDash: [5, 5]
                }
            }
        };
    }

    return options;
}

// Second renderVerificationTable function removed - bottom verification table deleted from UI

// Render runs table
function renderRunsTable(runs) {
    const tbody = document.getElementById('runsTable');
    tbody.innerHTML = '';

    for (const run of runs) {
        const initTime = new Date(run.run_id);
        const fetchedAt = run.fetched_at ? new Date(run.fetched_at) : null;
        const v = run.verification || {};

        // Build temp MAE string
        let tempMaeStr = '--';
        if (v.gfs_temp_mae !== undefined && v.gfs_temp_mae !== null) {
            tempMaeStr = `GFS: ${v.gfs_temp_mae}°`;
            if (v.aifs_temp_mae !== undefined && v.aifs_temp_mae !== null) {
                tempMaeStr += ` / AIFS: ${v.aifs_temp_mae}°`;
            }
            if (v.ifs_temp_mae !== undefined && v.ifs_temp_mae !== null) {
                tempMaeStr += ` / IFS: ${v.ifs_temp_mae}°`;
            }
        }

        // Build MSLP MAE string
        let mslpMaeStr = '--';
        if (v.gfs_mslp_mae !== undefined && v.gfs_mslp_mae !== null) {
            mslpMaeStr = `GFS: ${v.gfs_mslp_mae}`;
            if (v.aifs_mslp_mae !== undefined && v.aifs_mslp_mae !== null) {
                mslpMaeStr += ` / AIFS: ${v.aifs_mslp_mae}`;
            }
            if (v.ifs_mslp_mae !== undefined && v.ifs_mslp_mae !== null) {
                mslpMaeStr += ` / IFS: ${v.ifs_mslp_mae}`;
            }
            mslpMaeStr += ' mb';
        }

        const row = document.createElement('tr');
        row.innerHTML = `
            <td>
                <strong>${initTime.toLocaleString('en-US', { month: 'short', day: 'numeric', hour: '2-digit', hour12: false, timeZone: 'UTC' })}Z</strong>
                ${run.is_latest ? '<span class="badge bg-primary ms-2">Latest</span>' : ''}
            </td>
            <td>${fetchedAt ? fetchedAt.toLocaleString('en-US', { month: 'short', day: 'numeric', hour: '2-digit', minute: '2-digit', timeZoneName: 'short' }) : '--'}</td>
            <td>
                ${run.has_observations ?
                    '<span class="badge bg-success">Yes</span>' :
                    '<span class="badge bg-secondary">No</span>'}
            </td>
            <td>${tempMaeStr}</td>
            <td>${mslpMaeStr}</td>
        `;
        tbody.appendChild(row);
    }
}

// ============================================================================
// Fairfax Verification Time Series
// ============================================================================

let fairfaxTimeSeriesChart = null;

// Load and display Fairfax time series chart
async function loadFairfaxTimeSeriesChart() {
    const location = 'Fairfax, VA';
    const variable = document.getElementById('fairfaxTsVariable').value;
    const metric = document.getElementById('fairfaxTsMetric').value;
    const leadTime = document.getElementById('fairfaxTsLeadTime').value;
    const timeFrame = document.getElementById('fairfaxTsTimeFrame').value;

    try {
        const response = await fetch(
            `/api/verification-time-series?location=${encodeURIComponent(location)}&variable=${variable}&lead_time=${leadTime}&days_back=${timeFrame}`
        );
        const data = await response.json();

        if (!data.success) {
            console.error('Error loading Fairfax time series:', data.error);
            document.getElementById('fairfaxTimeSeriesSection').style.display = 'none';
            return;
        }

        // Show the section if data is available
        if (data.time_series && data.time_series.dates && data.time_series.dates.length > 0) {
            document.getElementById('fairfaxTimeSeriesSection').style.display = '';
            renderFairfaxTimeSeriesChart(data.time_series, metric, variable);
        } else {
            document.getElementById('fairfaxTimeSeriesSection').style.display = 'none';
        }

    } catch (error) {
        console.error('Error loading Fairfax time series chart:', error);
        document.getElementById('fairfaxTimeSeriesSection').style.display = 'none';
    }
}

// Render Fairfax time series chart
function renderFairfaxTimeSeriesChart(data, metric, variable) {
    const ctx = document.getElementById('fairfaxTimeSeriesChart');

    // Get the appropriate data arrays based on metric
    const gfsData = metric === 'mae' ? data.gfs.mae : data.gfs.bias;
    const aifsData = metric === 'mae' ? data.aifs.mae : data.aifs.bias;
    const ifsData = metric === 'mae' ? data.ifs.mae : data.ifs.bias;
    const nwsData = data.nws ? (metric === 'mae' ? data.nws.mae : data.nws.bias) : null;

    // Winner tally (only for MAE)
    const tallyEl = document.getElementById('fairfaxWinnerTally');
    if (metric === 'mae' && data.dates && data.dates.length > 0) {
        let gfsWins = 0;
        let aifsWins = 0;
        let ifsWins = 0;
        let nwsWins = 0;
        let tieWins = 0;

        for (let i = 0; i < data.dates.length; i++) {
            const candidates = [];
            const g = gfsData[i];
            const a = aifsData[i];
            const f = ifsData[i];
            const n = nwsData ? nwsData[i] : null;

            if (g !== null && g !== undefined) candidates.push({ key: 'gfs', val: g });
            if (a !== null && a !== undefined) candidates.push({ key: 'aifs', val: a });
            if (f !== null && f !== undefined) candidates.push({ key: 'ifs', val: f });
            if (n !== null && n !== undefined) candidates.push({ key: 'nws', val: n });

            if (candidates.length === 0) continue;
            const minVal = Math.min(...candidates.map(c => c.val));
            const winners = candidates.filter(c => c.val === minVal);

            if (winners.length === 1) {
                const w = winners[0].key;
                if (w === 'gfs') gfsWins += 1;
                else if (w === 'aifs') aifsWins += 1;
                else if (w === 'ifs') ifsWins += 1;
                else if (w === 'nws') nwsWins += 1;
            } else {
                tieWins += 1;
            }
        }

        document.getElementById('fairfaxGfsWins').textContent = gfsWins;
        document.getElementById('fairfaxAifsWins').textContent = aifsWins;
        document.getElementById('fairfaxIfsWins').textContent = ifsWins;
        document.getElementById('fairfaxNwsWins').textContent = nwsWins;
        document.getElementById('fairfaxTieWins').textContent = tieWins;
        tallyEl.classList.remove('d-none');
    } else if (tallyEl) {
        tallyEl.classList.add('d-none');
    }

    // Format dates for display
    const labels = data.dates.map(d => {
        const date = new Date(d);
        return date.toLocaleDateString('en-US', { month: 'short', day: 'numeric' });
    });

    // Determine units and labels
    const units = {
        'temp': '°F',
        'mslp': 'mb',
        'precip': 'in'
    };
    const unit = units[variable] || '';
    const metricLabel = metric.toUpperCase();
    const yAxisLabel = `${metricLabel} (${unit})`;

    // Destroy existing chart
    if (fairfaxTimeSeriesChart) {
        fairfaxTimeSeriesChart.destroy();
    }

    // Create new chart
    fairfaxTimeSeriesChart = new Chart(ctx, {
        type: 'line',
        data: {
            labels: labels,
            datasets: [
                {
                    label: 'GFS',
                    data: gfsData,
                    borderColor: '#0d6efd',
                    backgroundColor: 'rgba(13, 110, 253, 0.1)',
                    borderWidth: 2,
                    tension: 0.3,
                    pointRadius: 2,
                    pointHoverRadius: 5
                },
                {
                    label: 'AIFS',
                    data: aifsData,
                    borderColor: '#0dcaf0',
                    backgroundColor: 'rgba(13, 202, 240, 0.1)',
                    borderWidth: 2,
                    tension: 0.3,
                    pointRadius: 2,
                    pointHoverRadius: 5
                },
                {
                    label: 'IFS',
                    data: ifsData,
                    borderColor: '#20c997',
                    backgroundColor: 'rgba(32, 201, 151, 0.1)',
                    borderWidth: 2,
                    tension: 0.3,
                    pointRadius: 2,
                    pointHoverRadius: 5
                },
                ...(nwsData ? [{
                    label: 'NWS',
                    data: nwsData,
                    borderColor: '#111111',
                    backgroundColor: 'rgba(0, 0, 0, 0.05)',
                    borderWidth: 3,
                    borderDash: [6, 4],
                    tension: 0.3,
                    pointRadius: 2,
                    pointHoverRadius: 5
                }] : [])
            ]
        },
        options: {
            responsive: true,
            maintainAspectRatio: false,
            interaction: {
                mode: 'index',
                intersect: false
            },
            plugins: {
                legend: {
                    position: 'top',
                    labels: {
                        usePointStyle: true,
                        padding: 20
                    }
                },
                tooltip: {
                    callbacks: {
                        label: function(context) {
                            let label = context.dataset.label || '';
                            if (label) {
                                label += ': ';
                            }
                            if (context.parsed.y !== null) {
                                label += context.parsed.y.toFixed(2) + ' ' + unit;
                            }
                            return label;
                        }
                    }
                }
            },
            scales: {
                y: {
                    grid: { color: '#e0e0e0' },
                    title: {
                        display: true,
                        text: yAxisLabel
                    }
                },
                x: {
                    grid: { display: false },
                    title: {
                        display: true,
                        text: 'Date'
                    },
                    ticks: {
                        maxRotation: 45,
                        minRotation: 45
                    }
                }
            }
        }
    });
}

// Event listeners
// Event listeners for Fairfax time series controls
document.getElementById('fairfaxTsVariable').addEventListener('change', loadFairfaxTimeSeriesChart);
document.getElementById('fairfaxTsMetric').addEventListener('change', loadFairfaxTimeSeriesChart);
document.getElementById('fairfaxTsLeadTime').addEventListener('change', loadFairfaxTimeSeriesChart);
document.getElementById('fairfaxTsTimeFrame').addEventListener('change', loadFairfaxTimeSeriesChart);

// Update just the temperature chart without reloading everything
async function updateTempChart() {
    if (!currentData) return;

    const location = 'Fairfax, VA';
    const leadTime = document.getElementById('tempBiasLeadTime').value;
    const timeFrame = document.getElementById('tempBiasTimeFrame').value;

    const tempBiasHistoryResponse = await fetch(
        `/api/temp-bias-history?location=${encodeURIComponent(location)}&lead_time=${leadTime}&days_back=${timeFrame}`
    );
    const tempBiasHistoryData = await tempBiasHistoryResponse.json();
    const tempHistoryData = tempBiasHistoryData.success ? tempBiasHistoryData.history : null;

    // Re-render just the temperature chart
    renderTempChart(currentData, tempHistoryData, panguOverlay, nwsOverlay);
}

// Update just the MSLP chart without reloading everything
async function updateMslpChart() {
    if (!currentData) return;

    const location = 'Fairfax, VA';
    const leadTime = document.getElementById('mslpBiasLeadTime').value;
    const timeFrame = document.getElementById('mslpBiasTimeFrame').value;

    const mslpBiasHistoryResponse = await fetch(
        `/api/mslp-bias-history?location=${encodeURIComponent(location)}&lead_time=${leadTime}&days_back=${timeFrame}`
    );
    const mslpBiasHistoryData = await mslpBiasHistoryResponse.json();
    const mslpHistoryData = mslpBiasHistoryData.success ? mslpBiasHistoryData.history : null;

    // Re-render just the MSLP chart
    renderMslpChart(currentData, mslpHistoryData, panguOverlay);
}

// Update just the precipitation chart without reloading everything
async function updatePrecipChart() {
    const location = 'Fairfax, VA';
    const timeFrame = document.getElementById('precipDaysBack')?.value || document.getElementById('tempBiasTimeFrame').value;
    const leadTime = document.getElementById('precipBiasLeadTime')?.value || 24;
    try {
        const precipResponse = await fetch(
            `/api/precip-daily-history?location=${encodeURIComponent(location)}&days_back=${timeFrame}&future_days=15&lead_time=${leadTime}`
        );
        const precipData = await precipResponse.json();
        const precipHistoryData = precipData && precipData.success ? precipData : null;
        renderPrecipChart(precipHistoryData);
    } catch (error) {
        console.error('Error loading precipitation history:', error);
    }
}

// Event listeners for temperature bias history controls
document.getElementById('tempBiasLeadTime').addEventListener('change', updateTempChart);
document.getElementById('tempBiasTimeFrame').addEventListener('change', updateTempChart);
document.getElementById('tempBiasTimeFrame').addEventListener('change', updatePrecipChart);
document.getElementById('precipDaysBack')?.addEventListener('change', updatePrecipChart);
document.getElementById('precipBiasLeadTime')?.addEventListener('change', updatePrecipChart);

// Event listeners for MSLP bias history controls
document.getElementById('mslpBiasLeadTime').addEventListener('change', updateMslpChart);
document.getElementById('mslpBiasTimeFrame').addEventListener('change', updateMslpChart);
document.getElementById('fairfaxPeriodToggle').addEventListener('change', function() {
    loadVerificationTable();
    loadLeadTimeVerification();
});

// Initial load
document.addEventListener('DOMContentLoaded', function() {
    loadForecast();
    loadLeadTimeVerification();
    loadVerificationTable();
    loadFairfaxTimeSeriesChart();
});

// Expand/collapse table preview height
const tableToggle = document.getElementById('verificationTableToggle');
const tableContainer = document.getElementById('verificationTableContainer');
if (tableToggle && tableContainer) {
    tableToggle.addEventListener('click', () => {
        tableContainer.classList.toggle('table-preview');
        const expanded = !tableContainer.classList.contains('table-preview');
        tableToggle.textContent = expanded ? 'Collapse table' : 'Expand table';
    });
}

</script>
{% endblock %}
