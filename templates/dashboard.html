{% extends "base.html" %}

{% block title %}Fairfax Verification - Weather Forecast{% endblock %}

{% block extra_css %}
<style>
    .time-selector {
        display: flex;
        gap: 8px;
        flex-wrap: wrap;
    }
    .time-selector .btn {
        min-width: 50px;
    }

    .freezing-line {
        border-top: 2px dashed rgba(100, 149, 237, 0.5);
    }
</style>
{% endblock %}

{% block content %}
<div class="forecast-header">
    <div class="row align-items-center">
        <div class="col-md-6">
            <h1 class="mb-1"><i class="bi bi-cloud-sun"></i> Fairfax Verification</h1>
            <p class="mb-0 opacity-75">GFS vs ECMWF AIFS vs ECMWF IFS model forecasts</p>
        </div>
        <div class="col-md-6">
            <select class="form-select" id="locationSelect">
                {% for loc in locations %}
                <option value="{{ loc }}" {% if loc == selected_location %}selected{% endif %}>{{ loc }}</option>
                {% endfor %}
            </select>
        </div>
    </div>
</div>

<div id="loadingState" class="loading-spinner d-none">
    <div class="text-center">
        <div class="spinner-border text-primary" role="status"></div>
        <p class="mt-2 text-muted">Loading forecast data...</p>
    </div>
</div>

<div id="errorState" class="alert alert-warning d-none">
    <i class="bi bi-exclamation-triangle"></i>
    <span id="errorMessage">No data available.</span>
    <a href="/sync" class="alert-link ms-2">Go to Sync tab to fetch data</a>
</div>

<div id="forecastContent">
    <!-- Model Legend -->
    <div class="model-legend">
        <div class="model-legend-item">
            <span class="model-dot model-dot-gfs"></span>
            <span>GFS (NOAA)</span>
        </div>
        <div class="model-legend-item">
            <span class="model-dot model-dot-aifs"></span>
            <span>AIFS (ECMWF ML)</span>
        </div>
        <div class="model-legend-item">
            <span class="model-dot model-dot-ifs"></span>
            <span>IFS (ECMWF NWP)</span>
        </div>
        <div class="model-legend-item" id="observedLegend" style="display: none;">
            <span class="model-dot" style="background-color: #28a745;"></span>
            <span>Observed (WeatherLink)</span>
        </div>
    </div>

    <!-- Verification Stats (only shown when available) -->
    <div id="verificationSection" class="row mb-4" style="display: none;">
        <div class="col-12">
            <div class="card">
                <div class="card-header">
                    <i class="bi bi-check-circle"></i> Model Verification by Lead Time (vs Observed)
                </div>
                <div class="card-body p-0">
                    <div class="table-responsive">
                        <table class="table table-hover mb-0">
                            <thead>
                                <tr>
                                    <th>Lead Time</th>
                                    <th>Days</th>
                                    <th colspan="2" class="text-center bg-danger bg-opacity-10">GFS Temperature</th>
                                    <th colspan="2" class="text-center bg-warning bg-opacity-10">AIFS Temperature</th>
                                    <th colspan="2" class="text-center bg-success bg-opacity-10">IFS Temperature</th>
                                    <th>Winner</th>
                                    <th colspan="2" class="text-center bg-danger bg-opacity-10">GFS Pressure</th>
                                    <th colspan="2" class="text-center bg-warning bg-opacity-10">AIFS Pressure</th>
                                    <th colspan="2" class="text-center bg-success bg-opacity-10">IFS Pressure</th>
                                    <th>Samples</th>
                                </tr>
                                <tr>
                                    <th></th>
                                    <th></th>
                                    <th class="text-center">MAE</th>
                                    <th class="text-center">Bias</th>
                                    <th class="text-center">MAE</th>
                                    <th class="text-center">Bias</th>
                                    <th class="text-center">MAE</th>
                                    <th class="text-center">Bias</th>
                                    <th></th>
                                    <th class="text-center">MAE</th>
                                    <th class="text-center">Bias</th>
                                    <th class="text-center">MAE</th>
                                    <th class="text-center">Bias</th>
                                    <th class="text-center">MAE</th>
                                    <th class="text-center">Bias</th>
                                    <th></th>
                                </tr>
                            </thead>
                            <tbody id="verificationTableBody">
                                <tr>
                                    <td colspan="16" class="text-center text-muted">Loading...</td>
                                </tr>
                            </tbody>
                        </table>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Temperature Chart -->
    <div class="row mb-4">
        <div class="col-12">
            <div class="card">
                <div class="card-header d-flex justify-content-between align-items-center">
                    <span><i class="bi bi-thermometer-half"></i> Temperature Forecast</span>
                    <small class="text-muted" id="gfsInitTime"></small>
                </div>
                <div class="card-body">
                    <div class="chart-container chart-container-large">
                        <canvas id="tempChart"></canvas>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Precipitation Chart -->
    <div class="row mb-4">
        <div class="col-12">
            <div class="card">
                <div class="card-header d-flex justify-content-between align-items-center">
                    <span><i class="bi bi-cloud-rain"></i> 6-Hour Precipitation</span>
                    <small class="text-muted" id="aifsInitTime"></small>
                </div>
                <div class="card-body">
                    <div class="chart-container chart-container-large">
                        <canvas id="precipChart"></canvas>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- MSLP Chart -->
    <div class="row mb-4">
        <div class="col-12">
            <div class="card">
                <div class="card-header">
                    <i class="bi bi-speedometer"></i> Mean Sea Level Pressure
                </div>
                <div class="card-body">
                    <div class="chart-container chart-container-large">
                        <canvas id="mslpChart"></canvas>
                    </div>
                </div>
            </div>
        </div>
    </div>



<div id="verificationContent" class="d-none">
    <!-- Summary Stats -->
    <div class="row mb-4">
        <div class="col-lg-2 col-md-4 col-6 mb-3">
            <div class="card stat-card">
                <div class="stat-value" id="totalRuns">--</div>
                <div class="stat-label">Model Runs</div>
            </div>
        </div>
        <div class="col-lg-2 col-md-4 col-6 mb-3">
            <div class="card stat-card">
                <div class="stat-value" id="maxLeadTime">--</div>
                <div class="stat-label">Max Lead Time</div>
            </div>
        </div>
        <div class="col-lg-2 col-md-4 col-6 mb-3">
            <div class="card stat-card">
                <div class="stat-value stat-value-gfs" id="gfsAvgMae">--</div>
                <div class="stat-label">GFS Avg MAE</div>
            </div>
        </div>
        <div class="col-lg-2 col-md-4 col-6 mb-3">
            <div class="card stat-card">
                <div class="stat-value stat-value-aifs" id="aifsAvgMae">--</div>
                <div class="stat-label">AIFS Avg MAE</div>
            </div>
        </div>
        <div class="col-lg-2 col-md-4 col-6 mb-3">
            <div class="card stat-card">
                <div class="stat-value stat-value-ifs" id="ifsAvgMae">--</div>
                <div class="stat-label">IFS Avg MAE</div>
            </div>
        </div>
    </div>

    <!-- Model Legend -->
    <div class="model-legend">
        <div class="model-legend-item">
            <span class="model-dot model-dot-gfs"></span>
            <span>GFS (NOAA)</span>
        </div>
        <div class="model-legend-item">
            <span class="model-dot model-dot-aifs"></span>
            <span>AIFS (ECMWF ML)</span>
        </div>
        <div class="model-legend-item">
            <span class="model-dot model-dot-ifs"></span>
            <span>IFS (ECMWF NWP)</span>
        </div>
    </div>

    <!-- Temperature MAE Chart -->
    <div class="row mb-4">
        <div class="col-12">
            <div class="card">
                <div class="card-header">
                    <i class="bi bi-thermometer-half"></i> Temperature MAE by Lead Time
                    <small class="text-muted ms-2">(lower is better)</small>
                </div>
                <div class="card-body">
                    <div class="chart-container chart-container-large">
                        <canvas id="tempMaeChart"></canvas>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Temperature Bias Chart -->
    <div class="row mb-4">
        <div class="col-12">
            <div class="card">
                <div class="card-header">
                    <i class="bi bi-thermometer-half"></i> Temperature Bias by Lead Time
                    <small class="text-muted ms-2">(positive = warm bias, negative = cold bias)</small>
                </div>
                <div class="card-body">
                    <div class="chart-container chart-container-large">
                        <canvas id="tempBiasChart"></canvas>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- MSLP MAE Chart -->
    <div class="row mb-4">
        <div class="col-12">
            <div class="card">
                <div class="card-header">
                    <i class="bi bi-speedometer"></i> Pressure MAE by Lead Time
                    <small class="text-muted ms-2">(lower is better)</small>
                </div>
                <div class="card-body">
                    <div class="chart-container chart-container-large">
                        <canvas id="mslpMaeChart"></canvas>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- MSLP Bias Chart -->
    <div class="row mb-4">
        <div class="col-12">
            <div class="card">
                <div class="card-header">
                    <i class="bi bi-speedometer"></i> Pressure Bias by Lead Time
                    <small class="text-muted ms-2">(positive = high bias, negative = low bias)</small>
                </div>
                <div class="card-body">
                    <div class="chart-container chart-container-large">
                        <canvas id="mslpBiasChart"></canvas>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Data Table -->
    <div class="row mb-4">
        <div class="col-12">
            <div class="card">
                <div class="card-header">
                    <i class="bi bi-table"></i> Verification Statistics by Lead Time
                </div>
                <div class="card-body p-0">
                    <div class="table-responsive">
                        <table class="table table-hover mb-0">
                            <thead>
                                <tr>
                                    <th>Lead Time</th>
                                    <th>Days Out</th>
                                    <th>GFS Temp MAE</th>
                                    <th>AIFS Temp MAE</th>
                                    <th>IFS Temp MAE</th>
                                    <th>Winner</th>
                                    <th>GFS MSLP MAE</th>
                                    <th>AIFS MSLP MAE</th>
                                    <th>IFS MSLP MAE</th>
                                    <th>Samples</th>
                                </tr>
                            </thead>
                            <tbody id="verificationTable">
                                <!-- Populated by JavaScript -->
                            </tbody>
                        </table>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Historical Runs List -->
    <div class="row">
        <div class="col-12">
            <div class="card">
                <div class="card-header">
                    <i class="bi bi-clock-history"></i> Historical Model Runs
                </div>
                <div class="card-body p-0">
                    <div class="table-responsive">
                        <table class="table table-hover mb-0">
                            <thead>
                                <tr>
                                    <th>Init Time</th>
                                    <th>Fetched At</th>
                                    <th>Has Observations</th>
                                    <th>Temp MAE</th>
                                    <th>MSLP MAE</th>
                                </tr>
                            </thead>
                            <tbody id="runsTable">
                                <!-- Populated by JavaScript -->
                            </tbody>
                        </table>
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
    <!-- Model Info -->
    <div class="row mt-4">
        <div class="col-md-4 mb-3">
            <div class="card h-100">
                <div class="card-header">
                    <i class="bi bi-info-circle"></i> GFS (Global Forecast System)
                </div>
                <div class="card-body">
                    <ul class="mb-0">
                        <li>Operated by NOAA/NCEP</li>
                        <li>Resolution: 0.25° (~28 km)</li>
                        <li>Updates: Every 6 hours</li>
                        <li>Range: 16 days (384 hours)</li>
                        <li>Physics-based NWP model</li>
                    </ul>
                </div>
            </div>
        </div>
        <div class="col-md-4 mb-3">
            <div class="card h-100">
                <div class="card-header">
                    <i class="bi bi-info-circle"></i> ECMWF AIFS (AI Forecast)
                </div>
                <div class="card-body">
                    <ul class="mb-0">
                        <li>Operated by ECMWF</li>
                        <li>Resolution: 0.25° (~28 km)</li>
                        <li>Updates: Every 6 hours</li>
                        <li>Range: 15 days (360 hours)</li>
                        <li>Machine learning model</li>
                    </ul>
                </div>
            </div>
        </div>
        <div class="col-md-4 mb-3">
            <div class="card h-100">
                <div class="card-header">
                    <i class="bi bi-info-circle"></i> ECMWF IFS (Integrated Forecast)
                </div>
                <div class="card-body">
                    <ul class="mb-0">
                        <li>Operated by ECMWF</li>
                        <li>Resolution: 0.25° (~28 km)</li>
                        <li>Updates: Every 6 hours</li>
                        <li>Range: 10 days (240 hours)</li>
                        <li>Physics-based NWP model</li>
                    </ul>
                </div>
            </div>
        </div>
    </div>
</div>
{% endblock %}

{% block extra_js %}
<script>
let tempChart, precipChart, mslpChart;
let currentData = null;

// Format time for display
function formatTime(dateStr) {
    const date = new Date(dateStr);
    return date.toLocaleString('en-US', {
        month: 'short',
        day: 'numeric',
        hour: 'numeric',
        hour12: true
    });
}

function formatShortTime(dateStr) {
    const date = new Date(dateStr);
    return date.toLocaleString('en-US', {
        month: 'short',
        day: 'numeric'
    });
}

// Get temperature badge class
function getTempClass(temp) {
    if (temp < 32) return 'temp-cold';
    if (temp < 50) return 'temp-cool';
    if (temp < 75) return 'temp-warm';
    return 'temp-hot';
}

// Load forecast data from saved files
async function loadForecast() {
    const location = document.getElementById('locationSelect').value;

    document.getElementById('loadingState').classList.remove('d-none');
    document.getElementById('forecastContent').classList.add('d-none');
    document.getElementById('errorState').classList.add('d-none');

    try {
        // Load from saved data and verification across all runs
        const [forecastResponse, verificationResponse] = await Promise.all([
            fetch(`/api/latest-forecast?location=${encodeURIComponent(location)}`),
            fetch(`/api/verification-by-lead-time?location=${encodeURIComponent(location)}`)
        ]);

        const data = await forecastResponse.json();
        const verificationData = await verificationResponse.json();

        if (!data.success) {
            throw new Error(data.error || 'No saved data available');
        }

        currentData = data;
        document.getElementById('loadingState').classList.add('d-none');
        document.getElementById('forecastContent').classList.remove('d-none');

        renderForecastCharts(data);

        updateInitTimes(data);
        updateFetchedTime(data);
        updateObservedLegend(data);

        // Render verification table with accumulated data across all runs
        if (verificationData.success && verificationData.verification.lead_times.length > 0) {
            renderVerificationTable(verificationData.verification);
            document.getElementById('verificationSection').style.display = '';
        } else {
            const tbody = document.getElementById('verificationTableBody');
            tbody.innerHTML = '<tr><td colspan="10" class="text-center text-muted">No verification data available yet. Sync forecasts and wait for observations.</td></tr>';
            document.getElementById('verificationSection').style.display = '';
        }

    } catch (error) {
        console.error('Error loading forecast:', error);
        document.getElementById('loadingState').classList.add('d-none');
        document.getElementById('errorState').classList.remove('d-none');
        document.getElementById('errorMessage').textContent = error.message;
    }
}

// Update the "fetched at" time display
function updateFetchedTime(data) {
    if (data.fetched_at) {
        const fetchedAt = new Date(data.fetched_at);
        const timeStr = fetchedAt.toLocaleString('en-US', {
            month: 'short',
            day: 'numeric',
            hour: 'numeric',
            minute: '2-digit',
            hour12: true
        });
        // Add fetched time to the header if element exists
        const header = document.querySelector('.forecast-header p');
        if (header) {
            header.innerHTML = `GFS vs ECMWF AIFS vs ECMWF IFS model forecasts <span class="opacity-75">| Data from ${timeStr}</span>`;
        }
    }
}

// Update summary stats (removed - stats cards no longer displayed)

// Update init times
function updateInitTimes(data) {
    if (data.gfs.init_time) {
        const gfsInit = new Date(data.gfs.init_time);
        document.getElementById('gfsInitTime').textContent =
            'GFS: ' + gfsInit.toLocaleString('en-US', { month: 'short', day: 'numeric', hour: '2-digit', timeZoneName: 'short' });
    }
    if (data.aifs.init_time) {
        const aifsInit = new Date(data.aifs.init_time);
        document.getElementById('aifsInitTime').textContent =
            'AIFS/IFS: ' + aifsInit.toLocaleString('en-US', { month: 'short', day: 'numeric', hour: '2-digit', timeZoneName: 'short' });
    }
}

// Update observed legend visibility
function updateObservedLegend(data) {
    const hasObserved = data.observed && data.observed.temps && data.observed.temps.some(t => t !== null);
    document.getElementById('observedLegend').style.display = hasObserved ? '' : 'none';
}

// Format lead time for display
function formatLeadTime(hours) {
    if (hours < 24) {
        return hours + 'h';
    }
    const days = Math.floor(hours / 24);
    const remainingHours = hours % 24;
    if (remainingHours === 0) {
        return days + 'd';
    }
    return days + 'd ' + remainingHours + 'h';
}

// Render verification table with accumulated data across all runs
function renderVerificationTable(v) {
    const tbody = document.getElementById('verificationTableBody');
    tbody.innerHTML = '';

    const ifsTempMae = v.ifs_temp_mae || [];
    const ifsMslpMae = v.ifs_mslp_mae || [];

    for (let i = 0; i < v.lead_times.length; i++) {
        const lt = v.lead_times[i];
        const days = v.lead_times_days[i];

        // Temperature data
        const gfsTempMae = v.gfs_temp_mae[i];
        const gfsTempBias = v.gfs_temp_bias[i];
        const aifsTempMae = v.aifs_temp_mae[i];
        const aifsTempBias = v.aifs_temp_bias[i];
        const ifsTempMaeVal = ifsTempMae[i];
        const ifsTempBias = v.ifs_temp_bias ? v.ifs_temp_bias[i] : null;

        // Pressure data
        const gfsMslpMae = v.gfs_mslp_mae[i];
        const gfsMslpBias = v.gfs_mslp_bias[i];
        const aifsMslpMae = v.aifs_mslp_mae[i];
        const aifsMslpBias = v.aifs_mslp_bias[i];
        const ifsMslpMaeVal = ifsMslpMae[i];
        const ifsMslpBias = v.ifs_mslp_bias ? v.ifs_mslp_bias[i] : null;

        const samples = v.temp_sample_counts[i];

        // Determine winner - find lowest MAE among all models
        let winner = '--';
        let winnerClass = 'badge bg-secondary';
        const tempMaes = [
            { name: 'GFS', mae: gfsTempMae, class: 'badge bg-danger' },
            { name: 'AIFS', mae: aifsTempMae, class: 'badge bg-warning text-dark' },
            { name: 'IFS', mae: ifsTempMaeVal, class: 'badge bg-success' }
        ].filter(m => m.mae !== null && m.mae !== undefined);

        if (tempMaes.length > 0) {
            const minMae = Math.min(...tempMaes.map(m => m.mae));
            const winners = tempMaes.filter(m => m.mae === minMae);
            if (winners.length === 1) {
                winner = winners[0].name;
                winnerClass = winners[0].class;
            } else {
                winner = 'Tie';
                winnerClass = 'badge bg-secondary';
            }
        }

        const row = document.createElement('tr');
        row.innerHTML = `
            <td><strong>${formatLeadTime(lt)}</strong></td>
            <td>${days.toFixed(1)}</td>
            <td class="text-center">${gfsTempMae !== null ? gfsTempMae.toFixed(1) + '°F' : '--'}</td>
            <td class="text-center">${gfsTempBias !== null ? (gfsTempBias > 0 ? '+' : '') + gfsTempBias.toFixed(1) + '°F' : '--'}</td>
            <td class="text-center">${aifsTempMae !== null ? aifsTempMae.toFixed(1) + '°F' : '--'}</td>
            <td class="text-center">${aifsTempBias !== null ? (aifsTempBias > 0 ? '+' : '') + aifsTempBias.toFixed(1) + '°F' : '--'}</td>
            <td class="text-center">${ifsTempMaeVal !== null && ifsTempMaeVal !== undefined ? ifsTempMaeVal.toFixed(1) + '°F' : '--'}</td>
            <td class="text-center">${ifsTempBias !== null && ifsTempBias !== undefined ? (ifsTempBias > 0 ? '+' : '') + ifsTempBias.toFixed(1) + '°F' : '--'}</td>
            <td><span class="${winnerClass}">${winner}</span></td>
            <td class="text-center">${gfsMslpMae !== null ? gfsMslpMae.toFixed(1) + ' mb' : '--'}</td>
            <td class="text-center">${gfsMslpBias !== null ? (gfsMslpBias > 0 ? '+' : '') + gfsMslpBias.toFixed(1) + ' mb' : '--'}</td>
            <td class="text-center">${aifsMslpMae !== null ? aifsMslpMae.toFixed(1) + ' mb' : '--'}</td>
            <td class="text-center">${aifsMslpBias !== null ? (aifsMslpBias > 0 ? '+' : '') + aifsMslpBias.toFixed(1) + ' mb' : '--'}</td>
            <td class="text-center">${ifsMslpMaeVal !== null && ifsMslpMaeVal !== undefined ? ifsMslpMaeVal.toFixed(1) + ' mb' : '--'}</td>
            <td class="text-center">${ifsMslpBias !== null && ifsMslpBias !== undefined ? (ifsMslpBias > 0 ? '+' : '') + ifsMslpBias.toFixed(1) + ' mb' : '--'}</td>
            <td>${samples}</td>
        `;
        tbody.appendChild(row);
    }
}

// Render charts
function renderForecastCharts(data) {
    const gfsLabels = data.gfs.times.map(t => formatShortTime(t));
    const aifsLabels = data.aifs.times.map(t => formatShortTime(t));
    const ifsLabels = data.ifs ? data.ifs.times.map(t => formatShortTime(t)) : [];

    // Use the longer label set
    let labels = gfsLabels;
    if (aifsLabels.length > labels.length) labels = aifsLabels;
    if (ifsLabels.length > labels.length) labels = ifsLabels;

    // Check if we have observed data
    const hasObserved = data.observed && data.observed.temps && data.observed.temps.some(t => t !== null);

    // Temperature chart datasets
    const tempDatasets = [
        {
            label: 'GFS',
            data: data.gfs.temps,
            borderColor: '#dc3545',
            backgroundColor: 'rgba(220, 53, 69, 0.1)',
            fill: false,
            tension: 0.3,
            pointRadius: 2,
            pointHoverRadius: 5,
            borderWidth: 2
        },
        {
            label: 'AIFS',
            data: data.aifs.temps,
            borderColor: '#e85d2d',
            backgroundColor: 'rgba(232, 93, 45, 0.1)',
            fill: false,
            tension: 0.3,
            pointRadius: 2,
            pointHoverRadius: 5,
            borderWidth: 2,
            borderDash: [5, 5]
        }
    ];

    // Add IFS dataset if available
    if (data.ifs && data.ifs.temps) {
        tempDatasets.push({
            label: 'IFS',
            data: data.ifs.temps,
            borderColor: '#198754',
            backgroundColor: 'rgba(25, 135, 84, 0.1)',
            fill: false,
            tension: 0.3,
            pointRadius: 2,
            pointHoverRadius: 5,
            borderWidth: 2,
            borderDash: [2, 2]
        });
    }

    // Add observed dataset if available
    if (hasObserved) {
        tempDatasets.push({
            label: 'Observed',
            data: data.observed.temps,
            borderColor: '#28a745',
            backgroundColor: 'rgba(40, 167, 69, 0.1)',
            fill: false,
            tension: 0.3,
            pointRadius: 3,
            pointHoverRadius: 6,
            borderWidth: 2.5
        });
    }

    // Temperature chart
    if (tempChart) tempChart.destroy();
    tempChart = new Chart(document.getElementById('tempChart'), {
        type: 'line',
        data: {
            labels: labels,
            datasets: tempDatasets
        },
        options: {
            responsive: true,
            maintainAspectRatio: false,
            interaction: {
                mode: 'index',
                intersect: false
            },
            plugins: {
                legend: {
                    position: 'top',
                    labels: {
                        usePointStyle: true,
                        padding: 20
                    }
                },
                tooltip: {
                    callbacks: {
                        label: function(context) {
                            return context.dataset.label + ': ' +
                                (context.raw !== null ? context.raw.toFixed(1) + '°F' : 'N/A');
                        }
                    }
                }
            },
            scales: {
                y: {
                    grid: { color: '#e0e0e0' },
                    title: { display: true, text: 'Temperature (°F)' }
                },
                x: {
                    grid: { display: false },
                    ticks: {
                        maxRotation: 45,
                        minRotation: 45,
                        callback: function(value, index) {
                            // Show every 4th label for readability
                            return index % 4 === 0 ? this.getLabelForValue(value) : '';
                        }
                    }
                }
            }
        }
    });

    // Precipitation chart datasets
    const precipDatasets = [
        {
            label: 'GFS',
            data: data.gfs.precips,
            borderColor: '#0d6efd',
            backgroundColor: 'rgba(13, 110, 253, 0.2)',
            fill: true,
            tension: 0.3,
            pointRadius: 2,
            pointHoverRadius: 5,
            borderWidth: 2
        },
        {
            label: 'AIFS',
            data: data.aifs.precips,
            borderColor: '#0dcaf0',
            backgroundColor: 'rgba(13, 202, 240, 0.2)',
            fill: true,
            tension: 0.3,
            pointRadius: 2,
            pointHoverRadius: 5,
            borderWidth: 2,
            borderDash: [5, 5]
        }
    ];

    // Add IFS precipitation if available
    if (data.ifs && data.ifs.precips) {
        precipDatasets.push({
            label: 'IFS',
            data: data.ifs.precips,
            borderColor: '#20c997',
            backgroundColor: 'rgba(32, 201, 151, 0.2)',
            fill: true,
            tension: 0.3,
            pointRadius: 2,
            pointHoverRadius: 5,
            borderWidth: 2,
            borderDash: [2, 2]
        });
    }

    // Precipitation chart
    if (precipChart) precipChart.destroy();
    precipChart = new Chart(document.getElementById('precipChart'), {
        type: 'line',
        data: {
            labels: labels,
            datasets: precipDatasets
        },
        options: {
            responsive: true,
            maintainAspectRatio: false,
            interaction: {
                mode: 'index',
                intersect: false
            },
            plugins: {
                legend: {
                    position: 'top',
                    labels: {
                        usePointStyle: true,
                        padding: 20
                    }
                },
                tooltip: {
                    callbacks: {
                        label: function(context) {
                            return context.dataset.label + ': ' +
                                (context.raw !== null ? context.raw.toFixed(3) + ' in' : 'N/A');
                        }
                    }
                }
            },
            scales: {
                y: {
                    beginAtZero: true,
                    grid: { color: '#e0e0e0' },
                    title: { display: true, text: 'Precipitation (inches)' }
                },
                x: {
                    grid: { display: false },
                    ticks: {
                        maxRotation: 45,
                        minRotation: 45,
                        callback: function(value, index) {
                            return index % 4 === 0 ? this.getLabelForValue(value) : '';
                        }
                    }
                }
            }
        }
    });

    // MSLP chart datasets
    const mslpDatasets = [
        {
            label: 'GFS',
            data: data.gfs.mslps || [],
            borderColor: '#6f42c1',
            backgroundColor: 'rgba(111, 66, 193, 0.1)',
            fill: false,
            tension: 0.3,
            pointRadius: 2,
            pointHoverRadius: 5,
            borderWidth: 2
        },
        {
            label: 'AIFS',
            data: data.aifs.mslps || [],
            borderColor: '#d63384',
            backgroundColor: 'rgba(214, 51, 132, 0.1)',
            fill: false,
            tension: 0.3,
            pointRadius: 2,
            pointHoverRadius: 5,
            borderWidth: 2,
            borderDash: [5, 5]
        }
    ];

    // Add IFS MSLP if available
    if (data.ifs && data.ifs.mslps) {
        mslpDatasets.push({
            label: 'IFS',
            data: data.ifs.mslps || [],
            borderColor: '#fd7e14',
            backgroundColor: 'rgba(253, 126, 20, 0.1)',
            fill: false,
            tension: 0.3,
            pointRadius: 2,
            pointHoverRadius: 5,
            borderWidth: 2,
            borderDash: [2, 2]
        });
    }

    // Add observed MSLP if available
    const hasObservedMslp = data.observed && data.observed.mslps && data.observed.mslps.some(m => m !== null);
    if (hasObservedMslp) {
        mslpDatasets.push({
            label: 'Observed',
            data: data.observed.mslps,
            borderColor: '#28a745',
            backgroundColor: 'rgba(40, 167, 69, 0.1)',
            fill: false,
            tension: 0.3,
            pointRadius: 3,
            pointHoverRadius: 6,
            borderWidth: 2.5
        });
    }

    // MSLP chart
    if (mslpChart) mslpChart.destroy();
    mslpChart = new Chart(document.getElementById('mslpChart'), {
        type: 'line',
        data: {
            labels: labels,
            datasets: mslpDatasets
        },
        options: {
            responsive: true,
            maintainAspectRatio: false,
            interaction: {
                mode: 'index',
                intersect: false
            },
            plugins: {
                legend: {
                    position: 'top',
                    labels: {
                        usePointStyle: true,
                        padding: 20
                    }
                },
                tooltip: {
                    callbacks: {
                        label: function(context) {
                            return context.dataset.label + ': ' +
                                (context.raw !== null ? context.raw.toFixed(1) + ' mb' : 'N/A');
                        }
                    }
                }
            },
            scales: {
                y: {
                    grid: { color: '#e0e0e0' },
                    title: { display: true, text: 'Pressure (mb)' }
                },
                x: {
                    grid: { display: false },
                    ticks: {
                        maxRotation: 45,
                        minRotation: 45,
                        callback: function(value, index) {
                            return index % 4 === 0 ? this.getLabelForValue(value) : '';
                        }
                    }
                }
            }
        }
    });
}



let tempMaeChart, tempBiasChart, mslpMaeChart, mslpBiasChart;

// ============================================================================
// Existing Verification Functionality
// ============================================================================

// Format lead time for display
function formatLeadTime(hours) {
    if (hours < 24) {
        return hours + 'h';
    }
    const days = Math.floor(hours / 24);
    const remainingHours = hours % 24;
    if (remainingHours === 0) {
        return days + 'd';
    }
    return days + 'd ' + remainingHours + 'h';
}

// Load verification data
async function loadLeadTimeVerification() {
    const location = document.getElementById('locationSelect').value;

    document.getElementById('loadingState').classList.remove('d-none');
    document.getElementById('verificationContent').classList.add('d-none');
    document.getElementById('errorState').classList.add('d-none');

    try {
        const [verificationResponse, runsResponse] = await Promise.all([
            fetch(`/api/verification-by-lead-time?location=${encodeURIComponent(location)}`),
            fetch(`/api/runs?location=${encodeURIComponent(location)}`)
        ]);

        const verificationData = await verificationResponse.json();
        const runsData = await runsResponse.json();

        if (!verificationData.success) {
            throw new Error(verificationData.error || 'No verification data available');
        }

        const v = verificationData.verification;

        if (!v.lead_times || v.lead_times.length === 0) {
            throw new Error('No verified forecast data yet. Sync forecasts and wait for observations.');
        }

        document.getElementById('loadingState').classList.add('d-none');
        document.getElementById('verificationContent').classList.remove('d-none');

        updateVerificationSummaryStats(v);
        renderVerificationCharts(v);
        renderVerificationTable(v);

        if (runsData.success) {
            renderRunsTable(runsData.runs);
        }

    } catch (error) {
        console.error('Error loading verification:', error);
        document.getElementById('loadingState').classList.add('d-none');
        document.getElementById('errorState').classList.remove('d-none');
        document.getElementById('errorMessage').textContent = error.message;
    }
}

// Update summary statistics
function updateVerificationSummaryStats(v) {
    document.getElementById('totalRuns').textContent = v.run_count || '--';

    const maxLeadHours = v.lead_times.length > 0 ? Math.max(...v.lead_times) : 0;
    document.getElementById('maxLeadTime').textContent = formatLeadTime(maxLeadHours);

    // Calculate average MAE across all lead times
    const gfsTempMaes = v.gfs_temp_mae.filter(x => x !== null);
    const aifsTempMaes = v.aifs_temp_mae.filter(x => x !== null);
    const ifsTempMaes = (v.ifs_temp_mae || []).filter(x => x !== null);

    if (gfsTempMaes.length > 0) {
        const avgGfs = (gfsTempMaes.reduce((a, b) => a + b, 0) / gfsTempMaes.length).toFixed(1);
        document.getElementById('gfsAvgMae').textContent = avgGfs + '°F';
    }

    if (aifsTempMaes.length > 0) {
        const avgAifs = (aifsTempMaes.reduce((a, b) => a + b, 0) / aifsTempMaes.length).toFixed(1);
        document.getElementById('aifsAvgMae').textContent = avgAifs + '°F';
    }

    if (ifsTempMaes.length > 0) {
        const avgIfs = (ifsTempMaes.reduce((a, b) => a + b, 0) / ifsTempMaes.length).toFixed(1);
        document.getElementById('ifsAvgMae').textContent = avgIfs + '°F';
    }
}

// Render charts
function renderVerificationCharts(v) {
    const labels = v.lead_times.map(h => formatLeadTime(h));

    // Temperature MAE chart datasets
    const tempMaeDatasets = [
        {
            label: 'GFS',
            data: v.gfs_temp_mae,
            borderColor: '#dc3545',
            backgroundColor: 'rgba(220, 53, 69, 0.1)',
            fill: false,
            tension: 0.3,
            pointRadius: 3,
            borderWidth: 2
        },
        {
            label: 'AIFS',
            data: v.aifs_temp_mae,
            borderColor: '#e85d2d',
            backgroundColor: 'rgba(232, 93, 45, 0.1)',
            fill: false,
            tension: 0.3,
            pointRadius: 3,
            borderWidth: 2,
            borderDash: [5, 5]
        }
    ];

    if (v.ifs_temp_mae) {
        tempMaeDatasets.push({
            label: 'IFS',
            data: v.ifs_temp_mae,
            borderColor: '#198754',
            backgroundColor: 'rgba(25, 135, 84, 0.1)',
            fill: false,
            tension: 0.3,
            pointRadius: 3,
            borderWidth: 2,
            borderDash: [2, 2]
        });
    }

    // Temperature MAE chart
    if (tempMaeChart) tempMaeChart.destroy();
    tempMaeChart = new Chart(document.getElementById('tempMaeChart'), {
        type: 'line',
        data: { labels: labels, datasets: tempMaeDatasets },
        options: getVerificationChartOptions('Temperature MAE (°F)', 0)
    });

    // Temperature Bias chart datasets
    const tempBiasDatasets = [
        {
            label: 'GFS',
            data: v.gfs_temp_bias,
            borderColor: '#dc3545',
            fill: false,
            tension: 0.3,
            pointRadius: 3,
            borderWidth: 2
        },
        {
            label: 'AIFS',
            data: v.aifs_temp_bias,
            borderColor: '#e85d2d',
            fill: false,
            tension: 0.3,
            pointRadius: 3,
            borderWidth: 2,
            borderDash: [5, 5]
        }
    ];

    if (v.ifs_temp_bias) {
        tempBiasDatasets.push({
            label: 'IFS',
            data: v.ifs_temp_bias,
            borderColor: '#198754',
            fill: false,
            tension: 0.3,
            pointRadius: 3,
            borderWidth: 2,
            borderDash: [2, 2]
        });
    }

    // Temperature Bias chart
    if (tempBiasChart) tempBiasChart.destroy();
    tempBiasChart = new Chart(document.getElementById('tempBiasChart'), {
        type: 'line',
        data: { labels: labels, datasets: tempBiasDatasets },
        options: getVerificationChartOptions('Temperature Bias (°F)', null, true)
    });

    // MSLP MAE chart datasets
    const mslpMaeDatasets = [
        {
            label: 'GFS',
            data: v.gfs_mslp_mae,
            borderColor: '#6f42c1',
            fill: false,
            tension: 0.3,
            pointRadius: 3,
            borderWidth: 2
        },
        {
            label: 'AIFS',
            data: v.aifs_mslp_mae,
            borderColor: '#d63384',
            fill: false,
            tension: 0.3,
            pointRadius: 3,
            borderWidth: 2,
            borderDash: [5, 5]
        }
    ];

    if (v.ifs_mslp_mae) {
        mslpMaeDatasets.push({
            label: 'IFS',
            data: v.ifs_mslp_mae,
            borderColor: '#fd7e14',
            fill: false,
            tension: 0.3,
            pointRadius: 3,
            borderWidth: 2,
            borderDash: [2, 2]
        });
    }

    // MSLP MAE chart
    if (mslpMaeChart) mslpMaeChart.destroy();
    mslpMaeChart = new Chart(document.getElementById('mslpMaeChart'), {
        type: 'line',
        data: { labels: labels, datasets: mslpMaeDatasets },
        options: getVerificationChartOptions('Pressure MAE (mb)', 0)
    });

    // MSLP Bias chart datasets
    const mslpBiasDatasets = [
        {
            label: 'GFS',
            data: v.gfs_mslp_bias,
            borderColor: '#6f42c1',
            fill: false,
            tension: 0.3,
            pointRadius: 3,
            borderWidth: 2
        },
        {
            label: 'AIFS',
            data: v.aifs_mslp_bias,
            borderColor: '#d63384',
            fill: false,
            tension: 0.3,
            pointRadius: 3,
            borderWidth: 2,
            borderDash: [5, 5]
        }
    ];

    if (v.ifs_mslp_bias) {
        mslpBiasDatasets.push({
            label: 'IFS',
            data: v.ifs_mslp_bias,
            borderColor: '#fd7e14',
            fill: false,
            tension: 0.3,
            pointRadius: 3,
            borderWidth: 2,
            borderDash: [2, 2]
        });
    }

    // MSLP Bias chart
    if (mslpBiasChart) mslpBiasChart.destroy();
    mslpBiasChart = new Chart(document.getElementById('mslpBiasChart'), {
        type: 'line',
        data: { labels: labels, datasets: mslpBiasDatasets },
        options: getVerificationChartOptions('Pressure Bias (mb)', null, true)
    });
}

function getVerificationChartOptions(yLabel, minY = null, showZeroLine = false) {
    const options = {
        responsive: true,
        maintainAspectRatio: false,
        interaction: {
            mode: 'index',
            intersect: false
        },
        plugins: {
            legend: {
                position: 'top',
                labels: {
                    usePointStyle: true,
                    padding: 20
                }
            },
            annotation: { // Add this if you don't have it already
                annotations: {}
            }
        },
        scales: {
            y: {
                grid: { color: '#e0e0e0' },
                title: { display: true, text: yLabel }
            },
            x: {
                grid: { display: false },
                title: { display: true, text: 'Lead Time' }
            }
        }
    };

    if (minY !== null) {
        options.scales.y.min = minY;
    }

    if (showZeroLine) {
        options.plugins.annotation = {
            annotations: {
                zeroLine: {
                    type: 'line',
                    yMin: 0,
                    yMax: 0,
                    borderColor: '#999',
                    borderWidth: 1,
                    borderDash: [5, 5]
                }
            }
        };
    }

    return options;
}

// Render data table
function renderVerificationTable(v) {
    const tbody = document.getElementById('verificationTable');
    tbody.innerHTML = '';

    const ifsTempMae = v.ifs_temp_mae || [];
    const ifsMslpMae = v.ifs_mslp_mae || [];

    for (let i = 0; i < v.lead_times.length; i++) {
        const lt = v.lead_times[i];
        const days = v.lead_times_days[i];
        const gfsTempMae = v.gfs_temp_mae[i];
        const aifsTempMae = v.aifs_temp_mae[i];
        const ifsTempMaeVal = ifsTempMae[i];
        const gfsMslpMae = v.gfs_mslp_mae[i];
        const aifsMslpMae = v.aifs_mslp_mae[i];
        const ifsMslpMaeVal = ifsMslpMae[i];
        const samples = v.temp_sample_counts[i];

        // Determine winner - find lowest MAE among all models
        let winner = '--';
        let winnerClass = 'badge bg-secondary';
        const tempMaes = [
            { name: 'GFS', mae: gfsTempMae, class: 'badge bg-danger' },
            { name: 'AIFS', mae: aifsTempMae, class: 'badge bg-warning text-dark' },
            { name: 'IFS', mae: ifsTempMaeVal, class: 'badge bg-success' }
        ].filter(m => m.mae !== null && m.mae !== undefined);

        if (tempMaes.length > 0) {
            const minMae = Math.min(...tempMaes.map(m => m.mae));
            const winners = tempMaes.filter(m => m.mae === minMae);
            if (winners.length === 1) {
                winner = winners[0].name;
                winnerClass = winners[0].class;
            } else {
                winner = 'Tie';
                winnerClass = 'badge bg-secondary';
            }
        }

        const row = document.createElement('tr');
        row.innerHTML = `
            <td><strong>${formatLeadTime(lt)}</strong></td>
            <td>${days.toFixed(1)}</td>
            <td>${gfsTempMae !== null ? gfsTempMae.toFixed(1) + '°F' : '--'}</td>
            <td>${aifsTempMae !== null ? aifsTempMae.toFixed(1) + '°F' : '--'}</td>
            <td>${ifsTempMaeVal !== null && ifsTempMaeVal !== undefined ? ifsTempMaeVal.toFixed(1) + '°F' : '--'}</td>
            <td><span class="${winnerClass}">${winner}</span></td>
            <td>${gfsMslpMae !== null ? gfsMslpMae.toFixed(1) + ' mb' : '--'}</td>
            <td>${aifsMslpMae !== null ? aifsMslpMae.toFixed(1) + ' mb' : '--'}</td>
            <td>${ifsMslpMaeVal !== null && ifsMslpMaeVal !== undefined ? ifsMslpMaeVal.toFixed(1) + ' mb' : '--'}</td>
            <td>${samples}</td>
        `;
        tbody.appendChild(row);
    }
}

// Render runs table
function renderRunsTable(runs) {
    const tbody = document.getElementById('runsTable');
    tbody.innerHTML = '';

    for (const run of runs) {
        const initTime = new Date(run.run_id);
        const fetchedAt = run.fetched_at ? new Date(run.fetched_at) : null;
        const v = run.verification || {};

        // Build temp MAE string
        let tempMaeStr = '--';
        if (v.gfs_temp_mae !== undefined && v.gfs_temp_mae !== null) {
            tempMaeStr = `GFS: ${v.gfs_temp_mae}°`;
            if (v.aifs_temp_mae !== undefined && v.aifs_temp_mae !== null) {
                tempMaeStr += ` / AIFS: ${v.aifs_temp_mae}°`;
            }
            if (v.ifs_temp_mae !== undefined && v.ifs_temp_mae !== null) {
                tempMaeStr += ` / IFS: ${v.ifs_temp_mae}°`;
            }
        }

        // Build MSLP MAE string
        let mslpMaeStr = '--';
        if (v.gfs_mslp_mae !== undefined && v.gfs_mslp_mae !== null) {
            mslpMaeStr = `GFS: ${v.gfs_mslp_mae}`;
            if (v.aifs_mslp_mae !== undefined && v.aifs_mslp_mae !== null) {
                mslpMaeStr += ` / AIFS: ${v.aifs_mslp_mae}`;
            }
            if (v.ifs_mslp_mae !== undefined && v.ifs_mslp_mae !== null) {
                mslpMaeStr += ` / IFS: ${v.ifs_mslp_mae}`;
            }
            mslpMaeStr += ' mb';
        }

        const row = document.createElement('tr');
        row.innerHTML = `
            <td>
                <strong>${initTime.toLocaleString('en-US', { month: 'short', day: 'numeric', hour: '2-digit', timeZoneName: 'short' })}</strong>
                ${run.is_latest ? '<span class="badge bg-primary ms-2">Latest</span>' : ''}
            </td>
            <td>${fetchedAt ? fetchedAt.toLocaleString('en-US', { month: 'short', day: 'numeric', hour: '2-digit', minute: '2-digit' }) : '--'}</td>
            <td>
                ${run.has_observations ?
                    '<span class="badge bg-success">Yes</span>' :
                    '<span class="badge bg-secondary">No</span>'}
            </td>
            <td>${tempMaeStr}</td>
            <td>${mslpMaeStr}</td>
        `;
        tbody.appendChild(row);
    }
}

// Event listeners
document.getElementById('locationSelect').addEventListener('change', function() {
    loadForecast();
    loadLeadTimeVerification();
});

// Initial load
document.addEventListener('DOMContentLoaded', function() {
    loadForecast();
    loadLeadTimeVerification();
});

</script>
{% endblock %}
